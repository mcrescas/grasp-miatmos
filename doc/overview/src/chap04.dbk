<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE chapter SYSTEM "common_entities.dtd" 
[
<!ENTITY thetas '&#x03B8;<subscript xmlns="http://docbook.org/ns/docbook">s</subscript>'>
<!ENTITY thetav '&#x03B8;<subscript xmlns="http://docbook.org/ns/docbook">v</subscript>'>
<!ENTITY dphi   '&#x0394;&#x03D5;'>
<!ENTITY omega  '&#x03C9;'>
<!ENTITY Omega  '&#x03A9;'>
<!ENTITY PI     '&#x03C0;'>
<!ENTITY star   '&#x22C6;'>
<!ENTITY int    '&#x222B;'>
<!ENTITY nwl '<computeroutput xmlns="http://docbook.org/ns/docbook">nwl</computeroutput>' >
<!ENTITY iwl '<computeroutput xmlns="http://docbook.org/ns/docbook">iwl</computeroutput>' >
<!ENTITY nip '<computeroutput xmlns="http://docbook.org/ns/docbook">nip</computeroutput>' >
<!ENTITY ip '<computeroutput xmlns="http://docbook.org/ns/docbook">ip</computeroutput>' >
<!ENTITY nbvm '<computeroutput xmlns="http://docbook.org/ns/docbook">nbvm</computeroutput>' >
<!ENTITY ivm '<computeroutput xmlns="http://docbook.org/ns/docbook">ivm</computeroutput>' >
<!ENTITY nsurf '<computeroutput xmlns="http://docbook.org/ns/docbook">nsurf</computeroutput>' >
<!ENTITY ngas '<computeroutput xmlns="http://docbook.org/ns/docbook">ngas</computeroutput>' >
<!ENTITY groundpar '<computeroutput xmlns="http://docbook.org/ns/docbook">groundpar</computeroutput>' >
<!ENTITY gaspar '<computeroutput xmlns="http://docbook.org/ns/docbook">gaspar</computeroutput>' >
<!ENTITY ifcov '<computeroutput xmlns="http://docbook.org/ns/docbook">ifcov</computeroutput>' >
<!ENTITY cmtrx '<computeroutput xmlns="http://docbook.org/ns/docbook">cmtrx</computeroutput>' >
<!ENTITY ifmp '<computeroutput xmlns="http://docbook.org/ns/docbook">ifmp</computeroutput>' >
<!ENTITY mprof '<computeroutput xmlns="http://docbook.org/ns/docbook">mprof</computeroutput>' >
<!ENTITY meas_type '<computeroutput xmlns="http://docbook.org/ns/docbook">meas_type</computeroutput>' >
<!ENTITY meas '<computeroutput xmlns="http://docbook.org/ns/docbook">meas</computeroutput>' >
<!ENTITY sza '<computeroutput xmlns="http://docbook.org/ns/docbook">sza</computeroutput>' >
<!ENTITY vza '<computeroutput xmlns="http://docbook.org/ns/docbook">vza</computeroutput>' >
<!ENTITY raa '<computeroutput xmlns="http://docbook.org/ns/docbook">raa</computeroutput>' >
<!ENTITY wl1 '<computeroutput xmlns="http://docbook.org/ns/docbook">wl<subscript xmlns="http://docbook.org/ns/docbook">1</subscript></computeroutput>' >
<!ENTITY wl2 '<computeroutput xmlns="http://docbook.org/ns/docbook">wl<subscript xmlns="http://docbook.org/ns/docbook">2</subscript></computeroutput>' >
<!ENTITY wln '<computeroutput xmlns="http://docbook.org/ns/docbook">wl<subscript xmlns="http://docbook.org/ns/docbook">n</subscript></computeroutput>' >
<!ENTITY ipix '<computeroutput xmlns="http://docbook.org/ns/docbook">ipix</computeroutput>' >

<!ENTITY theta '&#x03B8;'>
<!ENTITY thetamin '&#x03B8;<superscript xmlns="http://docbook.org/ns/docbook">min</superscript>'>
<!ENTITY thetamax '&#x03B8;<superscript xmlns="http://docbook.org/ns/docbook">max</superscript>'>
<!ENTITY thetas '&#x03B8;<subscript xmlns="http://docbook.org/ns/docbook">s</subscript>'>
<!ENTITY thetav '&#x03B8;<subscript xmlns="http://docbook.org/ns/docbook">v</subscript>'>
<!ENTITY thetagb '&#x03B8;<subscript xmlns="http://docbook.org/ns/docbook">gb</subscript>'>
<!ENTITY thetan '&#x03B8;<subscript xmlns="http://docbook.org/ns/docbook">n</subscript>'>
<!ENTITY thetaG '&#x03B8;<subscript xmlns="http://docbook.org/ns/docbook">G</subscript>'>
<!ENTITY phi   '&#x03D5;'>
<!ENTITY phigb '&#x03D5;<subscript xmlns="http://docbook.org/ns/docbook">gb</subscript>'>
<!ENTITY phiG '&#x03D5;<subscript xmlns="http://docbook.org/ns/docbook">G</subscript>'>
<!ENTITY phis '&#x03D5;<subscript xmlns="http://docbook.org/ns/docbook">s</subscript>'>
<!ENTITY phiv '&#x03D5;<subscript xmlns="http://docbook.org/ns/docbook">v</subscript>'>
<!ENTITY dphi   '&#x0394;&#x03D5;'>
<!ENTITY omega  '&#x03C9;'>
<!ENTITY Omega  '&#x03A9;'>
<!ENTITY PI     '&#x03C0;'>
<!ENTITY star   '&#x22C6;'>
<!ENTITY degree '&#x00b0;'>
]>

<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xml:id="chap04">
    <title>How to use GRASP</title>
    
    <sect1>
        <title>How to run the code</title>
        <para>
            After the installation of &GRASP; software, the <command>grasp</command> command will be
            available. As it is explained in a previous section (see <xref linkend="running-code" />) just typing
            <command>grasp</command> will print some general information about how the software was compiled.
        </para>
        <para>    
            First arguments that <command>grasp</command> executable expects is a path to the settings file.
            The settings file describes the inversion strategy and general behaviour of the process: where is
            the input data, in which format is the input data, where to store the output results... Therefore, a deep knowledge
            of the settings parameters is the base to understand &GRASP;.
        </para>
        <sect2 id="settings-file">
            <title>Settings file</title>
            <para>
                Settings file is written in <link xl:href="http://en.wikipedia.org/wiki/YAML">YAML</link>
                format and that brings many benefits: easy to write, clear to read, self-explanatory names,
                flexible and powerful. The concepts are organized in blocks that are translated to YAML
                thanks to the fixed indentation (we suggest 4 white-spaces). So, for example, the first level defines
                the different modules:
            </para>
            <screen>                    
<?db-font-size 90% ?>
input:
    # Here settings related with input module
    segment: # It defines a description of the input segment
        x: 2 # It defines the maximum size of x dimension of the segment to 2.
output:
    # Settings linked with the output
    # ...
retrieval:
    # Definition of inversion strategy
    # ...
...
            </screen>
            <para>
                When &GRASP; is called, the first step is to read settings and the second is to prepare the environment
                for the settings defined in the main structures. If the settings are not valid, an explicit  
                error message will be printed. Please read the first line of it carefully to understand the error.
            </para>
            <para>
               The settings parameters can also be defined by the command line. In this case, after the first argument
               (settings file name), extra settings parameters can be defined with the syntax key=value where key is the
                parameter name in "dot syntax". For example, in &GRASP;, it is equivalent to be called with the argument <computeroutput>input.driver=sdata</computeroutput>
                or to have defined in the settings file the following content:
                <programlisting language="yml" >
input:
    driver: sdata
                </programlisting> 
            </para>
            <para>
                It is important to define clearly how the relative paths have to be defined in the settings files. Relative paths are always 
                relative to the file that defines it. In the next section, the reader will learn about how to include other settings file 
                inside of a settings file, but this rule will stay valid: Relative paths are defined from settings file that define it.
                In the case of usage of command line, relative paths are relative to the current working directory. In the case of absolute paths, all
                this complexity disappears but the results are less portables.
            </para>
            <sect3 id="help">
                <title>HELP argument</title>
                <para>
                    The list of available parameters for &GRASP; is long. The "help" argument will help you to know the available
                    parameters or to look for something specific. When <command>help</command> argument is present, &GRASP; is not 
                    executed normally, but instead, the help information will appear in the screen print. Additionally, help can be followed
                    by a search string to filter the results. For example, <command>help=input</command> will print only the settings
                    which contain "input" string in its definition and <command>help=input.segment</command> will print only the settings
                    which will be under the block "segment" inside of the block "input" (because "dot" symbol defines block separator).
                </para>

                <xi:include href="settings_parameters.dbk" />
            </sect3>
            <sect3>
                <title>Extending settings: command line, import and template statements </title>
                <para>
                    The first argument of &GRASP; has to be the settings file but this file can be modified by another
                    mechanism proposed by the settings module. The main way is by the command line, which allows to replace every settings
                    parameter with "dot" syntax (replacing indentation by "dot" symbol and colon symbol by equal). All parameters that have been defined before and being replaced in the command line will cause a "note" information during the execution of &GRASP;. 
                    That sentence is just to inform the user that command line arguments always have higher priority than parameters in 
                    settings files. The value from command line will be the value that will be used to run the code. The command line is a very
                    powerful feature to be used in the production scripts.
                </para>
                <para>
                    But the command line is not the only way to modify &GRASP; settings files. Settings files accept "import" and "template" statement.
                    These statements could look similar but theirs behaviour is a bit different. Both of them allow defining other settings files that are read before the current one, but in case of import, the settings can not be overwritten. The template statement allows loading other settings files and then, modifying some settings to customize the loaded file. It is necessary to take into account that these statements can be used in cascade, creating problems to debug the code. So please use these statements carefully.
                </para>
            </sect3>
            <sect3>
                <title>Streams</title>
                <para>
                    Some of the settings parameters are defined as "streams". GRASP output streams
                    allow users to create dynamic names avoiding overwriting files or having to change 
                    the filenames each time they execute &GRASP;. When a description of a parameter is defined
                    as "output stream", the user can set up a regular output path, for example <command>./folder/file.extension</command>
                    or use the "magic" behind the output streams by using a wildcard that will be replaced by dynamic values. For instance:
                </para>
     
                <screen>                    
<?db-font-size 90% ?>
output:
    segment:
        function: hdf
        stream: "GRASP_Banizoumbou_20080101_20080331_2x2+3286+1376.hdf"
    tile:
        function: [ ascii, hdf ] 
        stream: [ "GRASP_Banizoumbou_20080101_20080331.txt",
                "GRASP_Banizoumbou_20080101_20080331.hdf" ]
                </screen>
                <para> 
                    That definition is ok for many cases but if many tiles or segments are going to be processed,
                    the fixed names will produce name collisions (the content of some files will be overwritten during the process).
                    It would be tedious (and not always possible) for the user to change by himself the dates or other numeric substrings in
                    the file names. For this reason, the configuration system provides some wildcards
                    that will be automatically replaced with the given values depending on the state
                    of the processing. These wildcards are marked with curly braces and
                    their names are quite self-explanatory. The previous example can be rewritten in a more generic way using
                    the stream wildcards:
                </para>
                <screen>                    
<?db-font-size 70% ?>
output:
    segment:
        function: hdf
        stream: "GRASP_Banizoumbou_{tile_from(%Y%m%d)}_{tile_to(%Y%m%d)}_{segment_nx}x{segment_ny}//
        +{segment_corner_column(4)}+{segment_corner_row(4)}.hdf"
    tile:
        function: [ ascii, hdf ] 
        stream: [ "GRASP_Banizoumbou_{tile_from(%Y%m%d)}_{tile_to(%Y%m%d)}.txt",
                "GRASP_Banizoumbou_{tile_from(%Y%m%d)}_{tile_to(%Y%m%d)}.hdf" ]
                </screen>
                <para>
                    In addition, wildcards will provide the user the capability to set some system
                    streams. If you use the values "true", "screen", "t" or "1", the information will be printed
                    in the terminal (stdout). If the stream is set to "false", "none", "null", "f" or 0, nothing 
                    will be printed (like redirect to /dev/null). Finally, using the value "stderr" or "-1", the output
                    will be redirected to the standard error output.
                </para> 
                <para>
                    The following list shows all available wildcards that can be used for
                    creating dynamic output filenames:
                    <itemizedlist>
                        <listitem>
                            <emphasis role="bold">auto(N):</emphasis> itime x icol x irow with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">icol(N):</emphasis> current column number with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">irow(N):</emphasis> current row number with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">itime(N):</emphasis> current time number with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">iinversion(N):</emphasis> current inversion id with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">segment_nx(N):</emphasis> number of X elements per segment with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">segment_ny(N):</emphasis> number of Y elements per segment with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">segment_nt(N):</emphasis> number of T elements per segment with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_from(FORMAT):</emphasis> start tile date in FORMAT. By default FORMAT is %FT%H_%M_%SZ
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_to(FORMAT):</emphasis> final tile date in FORMAT. By default FORMAT is %FT%H_%M_%SZ
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_corner_column(N):</emphasis> number of the corner (column) of the segment defined in settings file. Requirement: Input data have to be defined using input.corner instead of input.center
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_corner_row(N):</emphasis> number of the corner of (row) the segment defined in settings file. Requirement: Input data have to be defined using input.corner instead of input.center
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_center_longitude(FORMAT):</emphasis> longitude of the center of the tile defined in settings file. Requirement: Input data have to be defined using input.center instead of input.corner
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_center_latitude(FORMAT):</emphasis> latitude of the center of the tile defined in settings file. Requirement: Input data have to be defined using input.center instead of input.corner
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_coordinate_x(I):</emphasis> x input reference of center of the tile defined in settings file. It can be defined by corner or latitude. If is N in case it was defined by corner or 0.I in case it was defined like center
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_coordinate_y(I):</emphasis> y input reference of center of the tile defined in settings file. It can be defined by corner or latitude. If is N in case it was defined by corner or 0.I in case it was defined like center
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_width(N):</emphasis> Number of X elements in tile with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">tile_height(N):</emphasis> Number of Y elements in tile with N zeros at the left
                        </listitem>
                        <listitem>
                            <emphasis role="bold">segment_corner_column(N):</emphasis> number of column of the segment corner with N zeros at the left. Requirement: Input data have to be defined using input.corner instead of input.center
                        </listitem>
                        <listitem>
                            <emphasis role="bold">segment_corner_row(N):</emphasis> number of row of the segment corner with N zeros at the left. Requirement: Input data have to be defined using input.corner instead of input.center
                        </listitem>
                        <listitem>
                            <emphasis role="bold">segment_first_date(FORMAT):</emphasis> date of first pixel inside the segment in FORMAT. By default FORMAT is %FT%H_%M_%SZ
                        </listitem>
                        <listitem>
                            <emphasis role="bold">segment_last_date(FORMAT):</emphasis> date of last pixel inside the segment in FORMAT. By default FORMAT is %FT%H_%M_%SZ
                        </listitem>
                        <listitem>
                            <emphasis role="bold">iteration(N):</emphasis> Number of iterations with N zeros at the left. (Note. In case of single pixel it returns the number of iterations of first pixel)
                        </listitem>
                        <listitem>
                            <emphasis role="bold">settings_filename:</emphasis> the name of settings file used to run the retrieval
                        </listitem>
                        <listitem>
                            <emphasis role="bold">version:</emphasis> version of grasp if it is compiled with saving this information
                        </listitem>
                        <listitem>
                            <emphasis role="bold">branch:</emphasis> git branch of grasp if it is compiled with saving this information
                        </listitem>
                        <listitem>
                            <emphasis role="bold">commit:</emphasis> reference of git commit of grasp if it is compiled with saving this information
                        </listitem>
                        <listitem>
                            <emphasis role="bold">constants_set:</emphasis> constants set used in compilation time
                        </listitem>
                        <listitem>
                            <emphasis role="bold">pwd:</emphasis> this is replaced by current folder and it is only valid at the beginning of the stream definition
                        </listitem>
                        <listitem>
                            <emphasis role="bold">yml:</emphasis> this is replaced by current folder of main configuration file and it is only valid at the beginning of the stream definition
                        </listitem>
                    </itemizedlist>
                </para>         
            </sect3>
        </sect2>
        <sect2 id="sect-iguess">
            <title>Retrieved characteristics</title>
            
            <para>
                The ensemble of characteristics available to be retrieved or simulated by &GRASP; is open to user selection in the settings file inside <emphasis>retrieval.constraints.characteristic</emphasis> section. An example of the general structure of them is showed below:
                <screen>
                <?db-font-size 80% ?>
retrieval:
    constraints:
        characteristic[1]:
            type: characteristic_name
            retrieved: true
            mode[1]:
                initial_guess:
                    value:                          [0.0, 0.0, 0.0, 0.0, ...]
                    min:                            [0.0, 0.0, 0.0, 0.0, ...]
                    max:                            [0.0, 0.0, 0.0, 0.0, ...]
                    index_of_wavelength_involved:   [0.0, 0.0, 0.0, 0.0, ...]
                single_pixel:
                    smoothness_constraints:
                        difference_order: 0.0
                        lagrange_multiplier: 0.0
                multi_pixel:
                    smoothness_constraints:
                        derivative_order_of_X_variability:    0.0
                        lagrange_multiplier_of_X_variability: 0.0
                        derivative_order_of_Y_variability:    0.0
                        lagrange_multiplier_of_Y_variability: 0.0
                        derivative_order_of_T_variability:    0.0
                        lagrange_multiplier_of_T_variability: 0.0
                    
            mode[2]:
            
                ...
            
            mode[3]:
            
                ...
                
            ...
                
                </screen>
            </para>
            
            <para>
                
                The number assigned at each characteristic has no relevance at all while coherence is maintained. The <emphasis>retrieved</emphasis> field can be set to 'true' if the corresponding characteristic is going to be a retrieved parameter in the inversion; or to 'false' if it is just a fixed value for the forward simulation. The number of modes included in each characteristic depends on the nature of each one. For characteristics representing optical or mycrophisical aerosol properties (size distribution or refractive index  for example), the number of modes corresponds to the number of aerosol modes selected for the retrieval/simulation (tipically one or two if fine/coarse distinction is made). For characteristics representing surface properties three modes will be needed to describe the associated model; except for polarization that only one is nedeed. The fields present in <emphasis>initial_guess</emphasis> part contain one element for each wavelength following the structure provided in the &SDATA; file in the case of optical wavelength dependent characteristics; one element for each bin for size distribution related characteristics; and one element for other mycrophysical magnitudes or non-wavelength dependent optical characteristics. In the former case, <emphasis>index_of_wavelength_involved</emphasis> should be filled with zeros for all the corresponding bins. The rest of the elements included in <emphasis>single_pixel</emphasis> or <emphasis>multi_pixel</emphasis> parts are always formed by one single element.
            </para>
            
            <para>
                
                The list of available characteristics can be found below:
                
            </para>
            
            <para>
                <table frame="all">
                    <title>Available &GRASP; characteristics</title>
                    <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colnum="1" colwidth="2*" />
                        <colspec colnum="2" colwidth="3*" />
                        <thead>
                            <row>
                                <entry>Characteristic  Name</entry>
                                <entry>Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>size_distribution_triangle_bins</entry>
                                <entry>
                                    Normalized Size Distribution dV / dlnr at "triangle" bins
                                </entry>
                            </row>
                            <row>
                                <entry>size_distribution_precalculated_lognormal</entry>
                                <entry>
                                    <para>
                                        Normalized Size Distribution dV / dlnr for precalculated lognormal bins
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry>size_distribution_lognormal</entry>
                                <entry>Parameters of bi - modal Lognormal Size Distribution dV / dlnr</entry>
                            </row>

                            <row>
                                <entry>aerosol_model_concentration</entry>
                                <entry>Aerosol model concentration</entry>
                            </row>
                            <row>
                                <entry>real_part_of_refractive_index_spectral_dependent</entry>
                                <entry>Spectral dependent Real part of complex refractive index</entry>
                            </row>

                            <row>
                                <entry>real_part_of_refractive_index_constant</entry>
                                <entry>Complex Refractive Index Real part is spectrally constant</entry>
                            </row>
                            <row>
                                <entry>particle_component_volume_fractions_linear_mixture</entry>
                                <entry>Real part of complex refractive index is mixture</entry>
                            </row>

                            <row>
                                <entry>particle_component_fractions_chemical_mixture</entry>
                                <entry>Chemistry, fraction of: water, fslbl, finslbl, soot, iron</entry>
                            </row>

                            <row>
                                <entry>imaginary_part_of_refractive_index_spectral_dependent</entry>
                                <entry>Spectral dependent Imaginary part of complex refractive index</entry>
                            </row>
                            <row>
                                <entry>imaginary_part_of_refractive_index_constant</entry>
                                <entry>Complex Refractive Index Imaginary part is spectrally constant</entry>
                            </row>

                            <row>
                                <entry>sphere_fraction</entry>
                                <entry>Fraction of spherical particles</entry>
                            </row>

                            <row>
                                <entry>aspect_ratio_distribution</entry>
                                <entry>Axis Ratio Distribution</entry>
                            </row>
                            <row>
                                <entry>vertical_profile_parameter_height</entry>
                                <entry>Scaling factor in case of exponential profile, mean height in case of gaussian distribution</entry>
                            </row>
                            <row>
                                <entry>vertical_profile_normalized</entry>
                                <entry>Aerosol normalized vertical profile</entry>
                            </row>
                            <row>
                                <entry>aerosol_concentration</entry>
                                <entry>Aerosol concentration</entry>
                            </row>
                            <row>
                                <entry>lidar_calibration_coefficient</entry>
                                <entry>Calibration coefficient for lidar</entry>
                            </row>
                            <row>
                                <entry>vertical_profile_parameter_standard_deviation</entry>
                                <entry>Standard deviation for aerosol vertical profile</entry>
                            </row>
                            <row>
                                <entry>surface_land_brdf_ross_li</entry>
                                <entry>BRDF Land normalized parameters according to Ross and Li model</entry>
                            </row>
                            <row>
                                <entry>surface_land_brdf_rpv</entry>
                                <entry>BRDF  normalized parameters according to RPV model</entry>
                            </row>
                            <row>
                                <entry>surface_land_litvinov</entry>
                                <entry>BRDF Land normalized parameters according to Litvinov model</entry>
                            </row>
                            <row>
                                <entry>surface_land_litvinov_fast</entry>
                                <entry>BRDF Land normalized parameters according to Litvinov fast model</entry>
                            </row>
                            <row>
                                <entry>surface_land_polarized_maignan_breon</entry>
                                <entry>BRDF Land normalized parameters according to Maignan and Breon model</entry>
                            </row>
                            <row>
                                <entry>surface_land_polarized_litvinov</entry>
                                <entry>BPDF Land normalized parameters according to Litvinov model</entry>
                            </row>
                            <row>
                                <entry>surface_water_cox_munk_iso</entry>
                                <entry>BRDF Water normalized parameters according to Cox and Munk model</entry>
                            </row>
                            <row>
                                <entry>surface_water_cox_munk_ani</entry>
                                <entry>BRDF normalized parameters according to Maignan and Breon model</entry>
                            </row>
                            <row>
                                <entry>surface_water_litvinov</entry>
                                <entry>BRDF Water normalized parameters according to Litvinov model</entry>
                            </row>

                        </tbody>
                    </tgroup>
                </table>
            </para>
            
            <sect3>
            <title>Initial guess through the algorithm</title>
            
            <para>
                Understanding &GRASP; inversion procedure means understanding how the algorithm is starting from an initial guess and
                obtains a results array. This is an iterative procedure explained in the literature and introduced in <xref linkend="scientific-algorithm" />.
                The purpose of this section is to explain how initial guess is represented inside the code as an array which evolves in each
                iteration until getting the result array. The following diagram shows how initial guess is read from settings file and translated
                into an internal array in the code. This detail could look very technical and related with the development but understanding
                of some internal concepts of the code helps to understand how it works. The following diagram shows this transformation:
            </para>

            <para role="Normal">
              <figure xml:id="iguess-settings-file">
                <title>Translation of settings file into initial guess array</title>
                <imagedata fileref="figures/iguess_settings.png" scalefit="1" width="100%" contentdepth="100%" align="center" />
              </figure>
            </para>
            <para>
            Since the initial guess is defined in the settings, it is defined once for the entire segment (one should remember that GRASP can work in a multi-pixel approach). Sometimes, it is desirable to have a different initial guess for each pixel. In that case the already described mechanisms to establish the initial guess are not enough, and GRASP proposes another useful tool to modify the initial guess of each segment. This information is considered as part of the input because it contains pixel dependent information and will be defined in detail in the <xref linkend="input_infor_char" />.
            </para>
            <para>
                Once the initial guess is loaded, it is set as first array of characteristics to be retrieved. Retrieval process iterates
                over it until it gets the results. The results of &GRASP;
                retrieval is the array with the same shape as the initial guess, but containing the results of retrieval of these parameters 
                to match them with SDATA file. Then, the GRASP forward model is called using this results array, &GRASP; obtains the rest 
                of the derived results it provides. So, we can talk about two kinds of results: basic results and derived products.
                The following diagram shows this process:
            </para>
            <para role="Normal">
              <figure xml:id="iguess-evolution">
                <title>Evolution of retrieved characteristics during GRASP processing</title>
                <imagedata fileref="figures/iguess_evolution.png" scalefit="1" width="100%" contentdepth="100%" align="center" />
              </figure>
            </para>              
            <para>
                To know all the details about the products obtained by &GRASP;, please see <xref linkend="grasp-output" />.
            </para>
            </sect3>
        </sect2>
        <sect2>
             <title>Noise simulation</title>
             <para>
                In order to harmonize all possibilities to add random noise to the measurements that are going to be retrieved in GRASP
                 a new setting called <emphasis>add_random_noise</emphasis> in the <emphasis>inversion.noises</emphasis> group has been created. There are three possible values that this 
                 setting can take: <emphasis>disable</emphasis>, <emphasis>measurement_fitting</emphasis> (default) and <emphasis>sdata</emphasis>. These options will produce a different effect depending 
                 on which retrieval mode (forward or inversion) has been selected. Here it is a small description of the meaning of the options: 
             </para>
             <para>
                <itemizedlist>
                        <listitem>
                            <emphasis>disable</emphasis>: If this option is selected there is no addition of any noise even if <emphasis>standard_deviation_synthetic</emphasis> greater than 0. 
                            All the rest of the settings related to it will be ignored.
                        </listitem>
                        <listitem>
                            <emphasis>measurement_fitting</emphasis>: This is the default value and this option maintains the same behaviour of GRASP random noise as before: for both <emphasis>forward</emphasis> and <emphasis>inversion</emphasis> 
                            retrieval modes random noise is added to FS measurement vector to be fitted.
                            <itemizedlist>
                                <listitem>
                                    If the <emphasis>forward</emphasis> option is selected in <emphasis>retrieval.mode</emphasis> any noise addition will be made. 
                                </listitem>
                                <listitem>
                                    If <emphasis>inversion</emphasis> is selected, the noise is added in the FS vector and it is totally transparent to the user. There is no possibility to 
                                    see what are the noisy measurements that are really being used in the retrieval. This option will always work no matter if the measurements in the sdata do
                                    really correspond or not with the ones that are being inverted (this is especially referred to the polarization measurements).
                                </listitem>
                            </itemizedlist>
                            </listitem>
                            <listitem>
                                <emphasis>sdata</emphasis>: the sdata mode is used to enable the user to see what are the noises added to the measurements. 
                                This option will only work if the measurements in the sdata and the measurements that are really retrieved 
                                are exactly the same. In other case, meaning that the code is fitting different measurements than those in the 
                                input data, an error will arise and the code will not be executed.  
                                <itemizedlist>
                                    <listitem>
                                        If the <emphasis>forward</emphasis> option is selected in retrieval.mode, the added noise will be done over the FS vector.
                                        It will be seen in the column <emphasis>fit_X</emphasis> of the output file, or if <emphasis>output.sdata.dump</emphasis> setting is 
                                        present in the yml file.
                                    </listitem>
                                    <listitem>
                                        If <emphasis>inversion</emphasis> is selected, the noise will be added to the original sdata provided by the user independently of the 
                                        forward model configuration. The noise measurements will be available for the user in the <emphasis>meas_X</emphasis> column of output 
                                        file or via <emphasis>input.sdata.dump</emphasis>. 
                                    </listitem>
                                </itemizedlist>
                            </listitem>
                </itemizedlist>
            </para>
             <para>
                <screen>
                <?db-font-size 80% ?>
 mode: inversion
    
    inversion:
        regime: single_pixel
        
        convergence:
            minimization_convention: logarithm
            maximum_iterations_for_stopping: 35
            maximum_iterations_of_Levenberg-Marquardt: 35 
            threshold_for_stopping: 1.0e-3
            threshold_for_stopping_Q_iterations: 1e-12
            scale_for_finite_difference: 1.0e-5  
            normal_system_solver: sparse_matrix_solver 

        measurement_fitting:
            polarization: degree_of_polarization                

        noises:
            add_random_noise: measurement_fitting # | disable | sdata
            noise[1]:
                standard_deviation_synthetic: 0.1
                error_type:  relative
                standard_deviation:  0.05
                measurement_type[1]:
                    type: I
                    index_of_wavelength_involved: [ 1, 2, 3, 4 ]
            noise[2]:
                standard_deviation_synthetic: 0.01
                error_type:  absolute
                standard_deviation:  0.005
                measurement_type[1]:
                    type: tod
                    index_of_wavelength_involved: [ 1, 2, 3, 4 ]
...
                
                </screen>
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Input module</title>
        <para>
            The input module is responsible for reading the data and for setting the internal input data structures. &GRASP;
            provides a very flexible way to inject the input data offering developers the capability to create the input drivers. 
            An input driver is an extension of &GRASP; that is added during compilation and is selected in the settings file.
            These generic drivers allow the developers to create a custom way to read a specific database and load it
            into the &GRASP; scientific algorithm. Therefore, &GRASP; can read infinite kinds of input databases, as much as drivers
            exist. Additionally, drivers can take the responsibility of performing some pre-processing actions (such as calibration
            corrections) before retrieving the data. Finally, when &GRASP; is used for massive data processing, drivers
            are extremely important since they help to prepare input data and load it into scientific module without the use
            of any intermediate files, everything is performed in memory. For general use, &GRASP; proposes a generic driver
            called the SData driver, which reads files in SData format (Sensor-Data format). These files are not standard, they have a
            specific format proposed by &GRASP; to start working with the code. This format is described in <xref linkend="sdata-format" />.
        </para>
        <para>
            Transformers are the second kind of extensions that the input module offers to users (and developers). They are called
            after getting input data for a segment, it means after calling the driver. The purpose of transformers is to add
            the capability to modify the segment after obtaining the data. An example of transformation is to load a climatology database
            and to modify the initial guess of each pixel to optimize the number of iterations needed to retrieve the data. Performing 
            this action after getting the data allows reusing it between different drivers. Default installation of &GRASP; does not offer
            any transformers. All of them are considered as optional extensions and have to be externally added manually or using
            the grasp-manager.
        </para>
        <sect2 id="sdata-format">
            <title>The SDATA format</title>
            <para>
                The &SDATA; (sensor data) format is the original input data format of the &GRASP; code. It is a simple text format designed by the 
                science team at the early stages of the development of the scientific code and it's the easiest way to create
                test data.
            </para>
            <para>
                In the context of the &GRASP; project, the &SDATA; format has a number of pros:
                <itemizedlist>
                    <listitem>Designed by the scientific team at the origin of the &GRASP; project, it is well adapted to its needs.</listitem>
                    <listitem>It is very simple to describe.</listitem>
                    <listitem>It is a text format, and therefore portable, quite easy to check (for the accustomed eye!) and to edit and to make some quick experiments.</listitem>
                    <listitem>It is a piece of cake to read in Fortran :-)</listitem>
                </itemizedlist>
            </para>
            <para>
                It has also a number of cons:
                <itemizedlist>
                    <listitem>It is not standard (a by-product of the "not designed by a committee" approach).
                        No off-the-shelf library is available to parse it and validate it (meaning outside of the &GRASP; project).</listitem>
                    <listitem>It lacks of flexibility: the order and the number of values are fixed for one version
                        and any change in the format to meet new requirements is likely to break the compatibility with
                        the former versions.
                    </listitem>
                    <listitem>
                        It is fragile: a malformed file may easily make the code crash or produce mysterious bugs. 
                        The design of the format, while simple, makes it hard to develop a really reliable validator.
                    </listitem>
                    <listitem>Comments are expected only after values, on the same line (after a colon sign)</listitem>
                    <listitem>While the format uses a text representation for the data, it contains lots of numeric
                        values, with limited accuracy and with no comment. Large files are tedious to read and it's
                        easy to make shift errors while reading and editing even for the experienced user.</listitem>
                    <listitem>
                        Being a text format, it becomes very inefficient for large data volumes. While it can be
                        compressed for archiving, it must be uncompressed for processing, and only sequential access
                        is possible. It is still possible to perform regional processings
                        (several dozens of thousands of pixels that cover more than a few hundreds 
                        of kilometres in both directions) with this format (it was actually done for the sake of
                        necessity), but it stresses the computing system a lot and can't be scaled up to the global processing.
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Whatever the number and seriousness of the cons, one of the design objectives is to keep the code simple and flexible
                allowing the scientific community to play with the code. It does not make sense to implement a driver for a single user who wants to do
                some tests with &GRASP;. That's why this easy format is maintained by the developer team.
            </para>    
            <para>
                In the following description, the elements in <computeroutput>fixed-width font</computeroutput> are the snippets of content. 
                The numeric values in these snippets (e.g. in <computeroutput>2 2 2 : NX NY NT</computeroutput>) are given only as examples.
            </para>
            <figure>
                <title>An example of SDATA file</title>
                <screen>        
<?db-font-size 80% ?>
SDATA version 2.0
2   2   2  : NX NY NT

4  2008-01-04T13:15:00Z 70000.0  0  0 : NPIXELS TIMESTAMP HOBS_km NSURF IFGAS
1  1  1	 3286  1377   2.599	13.528   252.0	 100.0  6  0.443  0.490  0.565 ...
2  1  1	 3287  1377   2.657	13.528   242.0	 100.0  6  0.443  0.490  0.565 ...
1  2  1	 3286  1376   2.601	13.583   241.0	 100.0  6  0.443  0.490  0.565 ...
2  2  1	 3287  1376   2.658	13.583   239.0	 100.0  6  0.443  0.490  0.565 ...


4  2008-01-06T13:02:41Z 70000.0  0  0 : NPIXELS TIMESTAMP HOBS_km NSURF IFGAS
1  1  1	 3286  1377   2.599	13.528   252.0	 100.0  6  0.443  0.490  0.565 ...
2  1  1	 3287  1377   2.657	13.528   242.0	 100.0  6  0.443  0.490  0.565 ...
1  2  1	 3286  1376   2.601	13.583   241.0	 100.0  6  0.443  0.490  0.565 ...
2  2  1	 3287  1376   2.658	13.583   239.0	 100.0  6  0.443  0.490  0.565 ...
                </screen>
            </figure>

            <para>
                SDATA files have a simple structure: 

                <orderedlist>
                    <listitem>
                        The first line is the FILE HEADER. It contains a magic identifier <computeroutput>SDATA</computeroutput>
                        followed by a version number.
                    </listitem>

                    <listitem>
                        The second line is the SEGMENT HEADER. It contains three numbers, <computeroutput>NX</computeroutput>,
                        <computeroutput>NY</computeroutput> and <computeroutput>NT</computeroutput>, 
                        the spatial and temporal dimensions of the segment that this SDATA file represents.
                        You can notice a colon and names of fields after the values. This is the way how comments
                        are written in the SDATA files. Everything starting from the colon will be ignored by
                        the SDATA parser.
                    </listitem>

                    <listitem>
                        An empty line follows the SEGMENT HEADER.
                    </listitem>

                    <listitem>
                        Then comes the first CELL (group of neighbouring pixels) of the SEGMENT. Each CELL has at most
                        NX*NY pixels (but it may have less, for various reasons: cloudy pixels that have been filtered,
                        missing pixels, etc.). The number of CELLs in the SEGMENT is given by the NT number provided
                        in the SEGMENT HEADER.
                    </listitem>

                </orderedlist>
            </para>

            <para>
                <table frame="all">
                    <title>The SDATA main structure</title>
                    <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colnum="1" colwidth="1*" />
                        <colspec colnum="2" colwidth="3*" />
                        <thead>
                            <row>
                                <entry>Field Name</entry>
                                <entry>Field Content</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>FILE HEADER</entry>
                                <entry>
                                    <computeroutput>SDATA version 2.0</computeroutput>
                                </entry>
                            </row>
                            <row>
                                <entry>SEGMENT HEADER</entry>
                                <entry>
                                    <para>
                                        <screen>2 2 2 : NX NY NT</screen>
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry>empty line</entry>
                                <entry></entry>
                            </row>

                            <row>
                                <entry>CELL 1</entry>
                                <entry>cell content, look for CELL structure</entry>
                            </row>
                            <row>
                                <entry>empty line</entry>
                                <entry></entry>
                            </row>

                            <row>
                                <entry>CELL 2</entry>
                                <entry>cell content, look for CELL structure</entry>
                            </row>
                            <row>
                                <entry>empty line</entry>
                                <entry></entry>
                            </row>

                            <row>
                                <entry>...</entry>
                                <entry></entry>
                            </row>

                            <row>
                                <entry>CELL it</entry>
                                <entry>cell content, look for CELL structure</entry>
                            </row>
                            <row>
                                <entry>empty line</entry>
                                <entry></entry>
                            </row>

                            <row>
                                <entry>...</entry>
                                <entry></entry>
                            </row>

                            <row>
                                <entry>CELL <computeroutput>NT</computeroutput></entry>
                                <entry>cell content, look for CELL structure</entry>
                            </row>
                            <row>
                                <entry>empty line</entry>
                                <entry></entry>
                            </row>

                        </tbody>
                    </tgroup>
                </table>
            </para>	

            <para>
                A CELL is a set of neighbouring pixels, that form the base of a SEGMENT. Each CELL has a HEADER
                and a number of PIXELs, supposedly acquired at the same time.
            </para>

            <para>
                The CELL HEADER contains:
                <orderedlist>
                    <listitem>
                        The number of pixels in the CELL (<computeroutput>NPIXELS</computeroutput>). It may not be
                        larger than <computeroutput>NX*NY</computeroutput>
                    </listitem>

                    <listitem>
                        The timestamp of acquisition of the pixels, in the 
                        <link xl:href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601</link> time format.
                    </listitem>

                    <listitem>
                        A "height" of observation, in metres. The value here is a bit weird (<computeroutput>70000</computeroutput>),
                        and doesn't correspond to the satellite altitude (that is at least 10 times larger). 
                        Actually, the value doesn't really matter as long as it is large. Historically, the scientific
                        team has used this value of <computeroutput>70000</computeroutput> in many SDATA files.
                    </listitem>

                    <listitem>
                        Two values for the number of surface and gas parameters. These two values are currently not documented and can be set to 0 for the moment.
                    </listitem>

                    <listitem>
                        Comments starting with a colon.
                    </listitem>
                </orderedlist>
            </para>

            <para>
                <table frame="all">
                    <title>The CELL structure</title>
                    <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colnum="1" colwidth="1*" />
                        <colspec colnum="2" colwidth="3*" />
                        <thead>
                            <row>
                                <entry>Field Name</entry>
                                <entry>Field Content</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>CELL HEADER</entry>
                                <entry>
                                    <mediaobject>
                                        <textobject role="html">
                                            <screen>4 2008-01-04T13:15:00Z 70000.0 0 0 : NPIXELS TIMESTAMP HOBS NSURF IFGAS</screen>
                                        </textobject>

                                        <textobject role="fo">
                                            <para>
                                                <screen>4 2008-01-04T13:15:00Z 70000.0 0 0 : NPIXELS ...</screen>
                                            </para>
                                            <para>
                                                <screen>   ... TIMESTAMP HOBS NSURF IFGAS</screen>
                                            </para>
                                        </textobject>
                                    </mediaobject>
                                </entry>
                            </row>
                            <row>
                                <entry>PIXEL 1</entry>
                                <entry>a line of values, look for PIXEL structure</entry>
                            </row>
                            <row>
                                <entry>PIXEL 2</entry>
                                <entry>a line of values, look for PIXEL structure</entry>
                            </row>
                            <row>
                                <entry>...</entry>
                            </row>
                            <row>
                                <entry>PIXEL <computeroutput>NPIXELS</computeroutput></entry>
                                <entry>a line of values, look for PIXEL structure</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>
                Each line of data after the CELL HEADER represents exactly one pixel, with all its fields. The <xref linkend="tablepixel" />
                describes the order and type of these fields. For the types, the Fortran notation is used:
                array types are described with the dimensions of arrays between parentheses, and the ordering is such that the
                first index increases faster. Indices start from 1, not from 0 like in C. For instance, when one reads 
                <computeroutput>real(nwl)</computeroutput> for wavelengths, that means that one has to read a list of 
                <computeroutput>nwl</computeroutput> real values that represent wavelengths.
            </para>

            <para>
                <table frame="all" xml:id="tablepixel">
                    <title>The PIXEL structure</title>
                    <tgroup cols="3" align="left" colsep="1" rowsep="1">
                        <colspec colnum="1" colwidth="1*" />
                        <colspec colnum="2" colwidth="2*" />
                        <colspec colnum="3" colwidth="4*" />
                        <thead>
                            <row>
                                <entry>Field Type</entry>
                                <entry>Variable Name (in source code)</entry>
                                <entry>Field Content</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>integer</entry>
                                <entry>pixel[&ipix;].ix</entry>
                                <entry>coordinate x in the current cell, starting at 1 (in the direction EW)</entry>
                            </row>

                            <row>
                                <entry>integer</entry>
                                <entry>pixel[&ipix;].iy</entry>
                                <entry>coordinate y in the current cell, starting at 1 (in the direction NS)</entry>
                            </row>

                            <row>
                                <footnote id="fncloud">
                                    <para>
                                        This fairly counter-intuitive coding has a reason: the cloud flag was at first intended to be
                                        a general processing flag (0 = pixel not to be processed, 1 = to be processed), cloud contamination is only
                                        one particular case. Now the flag is limited to cloud screening, but unfortunately
                                        the coding couldn't be changed right away. Since the framework is still in development, it is
                                        planned to correct this unnatural feature in the near future.
                                    </para>
                                </footnote>

                                <entry>integer</entry>
                                <entry>pixel[&ipix;].icloudy</entry>
                                <entry>cloud flag: 0 = cloud, 1 = clear <footnoteref linkend="fncloud" /></entry>
                            </row>

                            <row>

                                <footnote id="fngridcoord">
                                    <para>
                                        These fields are actually not used by the processing and therefore the SDATA implementer is
                                        free to put whatever he or she likes here (e.g. 0 for non-gridded data). They are intended mainly
                                        for documentation and debugging. For satellite data, they make it possible to retrieve the
                                        pixel original information in the original database.
                                    </para>
                                </footnote>

                                <entry>integer</entry>
                                <entry>pixel[&ipix;].icol</entry>
                                <entry>column of the pixel in its original grid or database (can be set to 0 when not relevant)<footnoteref linkend="fngridcoord" /></entry>
                            </row>

                            <row>
                                <entry>integer</entry>
                                <entry>pixel[&ipix;].irow</entry>
                                <entry>line of the pixel in its original grid or database (can be set to 0 when not relevant)<footnoteref linkend="fngridcoord" /></entry>
                            </row>

                            <row>
                                <entry>real</entry>
                                <entry>pixel[&ipix;].x</entry>
                                <entry>
                                    <para>longitude of the pixel, in decimal degrees, in the range [-180..180]</para>
                                    <para>0: Greenwich meridian, east of Greenwich: positive, west of Greenwich: negative</para>
                                </entry>
                            </row>

                            <row>
                                <entry>real</entry>
                                <entry>pixel[&ipix;].y</entry>
                                <entry>
                                    <para>latitude of the pixel, in decimal degrees, in the range [-90..90]</para>
                                </entry>
                            </row>

                            <row>
                                <entry>real</entry>
                                <entry>pixel[&ipix;].MASL</entry>
                                <entry>altitude of the ground, in metres (MASL: metres above sea level)</entry>
                            </row>

                            <row>
                                <entry>real</entry>
                                <entry>pixel[&ipix;].land_percent</entry>
                                <entry>percentage of land, in the range [0 (sea) .. 100 (land)]. Intermediate values correspond to coastal pixels</entry>
                            </row>

                            <row>
                                <entry>integer</entry>
                                <entry>pixel[&ipix;].nwl</entry>
                                <entry>number of available wavelengths (&nwl;)</entry>
                            </row>

                            <row>
                                <entry>real(&nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].wl</entry>
                                <entry>list of wavelengths, in micrometers</entry>
                            </row>

                            <row>
                                <entry>integer(&nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].nip</entry>
                                <entry>number of types of measurements for each wavelength (&nip;)</entry>
                            </row>

                            <row>
                                <entry>integer(&nip;, &nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].meas_type[&nip;]</entry>
                                <entry>
                                    <para>list of types of measurements &meas_type; (see <xref linkend="tabletypesmeasurements" />)</para>
                                    <para>The ordering is as follows: &meas_type;(1, &wl1;) &meas_type;(2, &wl1;) ... &meas_type;(&nip;, &wl1;) &meas_type;(1, &wl2;) ... &meas_type;(&nip;, &wln;)</para>
                                </entry>
                            </row>

                            <row>
                                <entry>integer(&nip;, &nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].nbvm[&nip;]</entry>
                                <entry>
                                    <para>number of valid measurements (&nbvm;), for each type of measurement and for each wavelength</para>
                                    <para>The ordering is as follows: &nbvm;(1, &wl1;) &nbvm;(2, &wl1;) ... &nbvm;(&nip;, &wl1;) &nbvm;(1, &wl2;) ... meas_type(&nip;, &wln;)</para>
                                </entry>
                            </row>

                            <row>
                                <entry>real(&nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].sza</entry>
                                <entry>solar/sounding zenith angle (&sza; or &thetas;) in decimal degrees ([0..90]), for each wavelength</entry>
                            </row>

                            <row>
                                <entry>real(&nbvm;, &nip;, &nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].thetav[&nip;][&nbvm;]</entry>
                                <entry>
                                    <para>viewing zenith angle (&vza; or &thetav;) in decimal degrees ([0..90] for &PARASOL;, TBD for PHOTOMETERS)</para>
                                    <para>The ordering is as follows: &thetav;(1, 1, &wl1;) &vza;(2, 1, &wl1;) ... &thetav;(&nbvm;, 1, &wl1;) &thetav;(1, 2, &wl1;) ... &thetav;(&nbvm;, &nip;, &wln;)</para>
                                    <para>In case of lidar or vertical observations this field contains altitudes or ranges of the observations in meters.</para>
                                </entry>
                            </row>

                            <row>
                                <entry>real(&nbvm;, &nip;, &nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].phi[&nip;][&nbvm;]</entry>
                                <entry>
                                    <para>relative azimuth angle (&raa; or &dphi;) in decimal degrees ([-180..180] or [0..360])</para>
                                    <para>The ordering is as follows: &dphi;(1, 1, &wl1;) &dphi;(2, 1, &wl1;) ... &dphi;(&nbvm;, 1, &wl1;) &dphi;(1, 2, &wl1;) ... &dphi;(&nbvm;, &nip;, &wln;)</para>
                                </entry>
                            </row>

                            <row>
                                <entry>real(&nbvm;, &nip;, &nwl;)</entry>
                                <entry>
                                    <para>pixel[&ipix;].meas[&nwl;]</para>
                                    <para>.tau[&nbvm;];...;.P[&nbvm;]</para>
                                </entry>
                                <entry>
                                    <para>measurements (depending on &meas_type;), for each wavelength</para>
                                    <para>The ordering is as follows: &meas;(1, 1, &wl1;) &meas;(2, 1, &wl1;) ... &meas;(&nbvm;, 1, &wl1;) &meas;(1, 2, &wl1;) ... &meas;(&nbvm;, &nip;, &wln;)</para>
                                    <para>Where meas can be: tau ... P</para>
                                </entry>
                            </row>

                            <row>
                                <entry>real(&nsurf;, &nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].groundpar[&nsurf;]</entry>
                                <entry>
                                    <para>ground parameters</para>
                                    <para>This part can be ignored for now. The ordering is as follows: &groundpar;(1, &wl1;) &groundpar;(2, &wl1;) ... &groundpar;(&nsurf;, &wl1;) &groundpar;(1, &wl2;) ... &groundpar;(&nsurf;, &wln;)</para>
                                </entry>
                            </row>

                            <row>
                                <entry>real(&nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].gaspar</entry>
                                <entry>
                                    <para>gas absorption (tau gases) or molecular depolarization ratio. This parameter has to be
                                        provided only if the setting IFGAS (in the CELL HEADER) is set to 1.</para>
                                    <para>The
                                        ordering is as follows: &gaspar;(&wl1;) &gaspar;(&wl2;) ... &gaspar;(&wln;)</para>
                                </entry>
                            </row>

                            <row>
                                <entry>integer(&nip;, &nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].ifcov[&nip;]</entry>
                                <entry>
                                    <para>&ifcov; (1 if a covariance matrix is available, 0 otherwise)</para>
                                    <para>The ordering is as follows: &ifcov;(1, &wl1;) &ifcov;(2, &wl1;) ... &ifcov;(&nip;, &wl1;) &ifcov;(1, &wl2;) ... &ifcov;(&nip;, &wln;)</para>
                                </entry>
                            </row>

                            <row>
                                <footnote id="fncmtrx">
                                    <para>
        &nbvm; is actually to be multiplied by &ifcov;(&ip;, &iwl;). If this last number equals 0, the array reduces to an empty set and no value is to be read.
                                    </para>
                                </footnote>

                                <entry>real(&nbvm;, &nip;, &nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].cmtrx[&nip;][&nbvm;]</entry>
                                <entry>
                                    <para>&cmtrx; (diagonal of covariance matrix, also known as &Omega;). These values have to be skipped if ifcov=0</para>
                                    <para>The ordering is as follows: &cmtrx;(1, 1, &wl1;) &cmtrx;(2, 1, &wl1;) ... 
      &cmtrx;(&nbvm;<footnoteref linkend="fncmtrx" />, 1, &wl1;) &cmtrx;(1, 2, &wl2;) ... &cmtrx;(&nbvm;<footnoteref linkend="fncmtrx" />, &nip;, &wln;)</para>
                                </entry>
                            </row>

                            <row>
                                <entry>integer(&nip;, &nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].ifmp[&nip;]</entry>
                                <entry>
                                    <para>&ifmp; (1 if a vertical profile (&mprof;) is available, 0 otherwise)</para>
                                    <para>The ordering is as follows: &ifmp;(1, &wl1;) &ifmp;(2, &wl1;) ... &ifmp;(&nip;, &wl1;) &ifmp;(1, &wl2;) ... &ifmp;(&nip;, &wln;)</para>
                                </entry>
                            </row>

                            <row>
                                <footnote id="fnmprof">
                                    <para>
        &nbvm; is actually to be multiplied by &ifmp;(&ip;, &iwl;). If this last number equals 0, the array reduces to an empty set and no value is to be read.
                                    </para>
                                </footnote>

                                <entry>real(&nbvm;, &nip;, &nwl;)</entry>
                                <entry>pixel[&ipix;].meas[&nwl;].mprof[&nip;][&nbvm;]</entry>
                                <entry>
                                    <para>&mprof; (vertical profile of Rayleigh backscattering). These values have to be skipped if ifmp=0</para>
                                    <para>The ordering is as follows: &mprof;(1, 1, &wl1;) &mprof;(2, 1, &wl1;) ... 
      &mprof;(&nbvm;<footnoteref linkend="fnmprof" />, 1, &wl1;) &mprof;(1, 2, &wl2;) ... &mprof;(&nbvm;<footnoteref linkend="fnmprof" />, &nip;, &wln;)</para>
                                </entry>
                            </row>

                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>
                The field <command>pixel[&ipix;].meas[&nwl;].meas_type[&nip;]</command> of pixel structure is a special code which defines
                the type of measure. The following table describes the valid codes and their interpretation:
            </para>
            <para>
                <table frame="all" xml:id="tabletypesmeasurements">
                    <title>Types of measurements</title>
                    <tgroup cols="3" align="left" colsep="1" rowsep="1">
                        <colspec colnum="1" colwidth="2*" />
                        <colspec colnum="2" colwidth="1*" />
                        <colspec colnum="4" colwidth="3*" />
                        <thead>
                            <row>
                                <entry>Constant Name (used in source code)</entry>
                                <entry>Value (SDATA 2.0)</entry>
                                <entry>Meaning</entry>
                            </row>
                        </thead>
                        <tbody>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_UNKNOWN</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>0</computeroutput>
                                </entry>
                                <entry>The measurement type is invalid or not yet implemented</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_TOD</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>11</computeroutput>
                                </entry>
                                <entry>Total Optical Depth</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_AOD</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>12</computeroutput>
                                </entry>
                                <entry>Aerosol Optical Depth</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_ABS</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>13</computeroutput>
                                </entry>
                                <entry>Aerosol absorption optical depth</entry>
                            </row>
                            
                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P11</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>21</computeroutput>
                                </entry>
                                <entry>Phase Matrix Element P11</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P12</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>22</computeroutput>
                                </entry>
                                <entry>Phase Matrix Element P12</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P22</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>23</computeroutput>
                                </entry>
                                <entry>Phase Matrix Element P22</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P33</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>24</computeroutput>
                                </entry>
                                <entry>Phase Matrix Element P33</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P34</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>25</computeroutput>
                                </entry>
                                <entry>Phase Matrix Element P34</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P44</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>26</computeroutput>
                                </entry>
                                <entry>Phase Matrix Element P44</entry>
                            </row>
                            
                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P11_rel_ang</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>27</computeroutput>
                                </entry>
                                <entry><mathphrase>p11/p11(given_angle)</mathphrase> phase matrix element</entry>
                            </row>
                            
                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P12_rel</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>28</computeroutput>
                                </entry>
                                <entry><mathphrase>-p12/p11</mathphrase> phase matrix element</entry>
                            </row>
                            
                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_LS</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>31</computeroutput>
                                </entry>
                                <entry>Lidar Signal</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_RL</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>32</computeroutput>
                                </entry>
                                <entry>Raman Lidar Signal</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_DP</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>35</computeroutput>
                                </entry>
                                <entry>Volume Depolarization Ratio</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_VEXT</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>36</computeroutput>
                                </entry>
                                <entry>Vertical Extinction profile</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_VBS</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>39</computeroutput>
                                </entry>
                                <entry>Vertical Backscatter profile</entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_I</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>41</computeroutput>
                                </entry>
                                <entry>Normalized Radiance I
                                    <footnote id="fnStokes">
                                        <para>
                                            All the Stokes Parameters are to be expressed
                                            as reduced quantities, without dimension
                                            <equation>
                                                <title>Conversion from absolute radiances to normalized, reduced radiances</title>
                                                I = radiance * &PI; / E0 
                                            </equation>
                                            where radiance is the radiance of the instrument, and E0 the solar
                                            spectral flux, that may be both in mW / (m^2 * sr * nm) or
                                            equivalent units
                                        </para>
                                    </footnote>
                                </entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_Q</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>42</computeroutput>
                                </entry>
                                <entry>Polarized radiance Q<footnoteref linkend="fnStokes" /></entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_U</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>43</computeroutput>
                                </entry>
                                <entry>Polarized Radiance U<footnoteref linkend="fnStokes" /></entry>
                            </row>

                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>44</computeroutput>
                                </entry>
                                <entry>Polarization Rate: <mathphrase>P = sqrt(Q*Q + U*U)/I</mathphrase></entry>
                            </row>
                            
                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>44</computeroutput>
                                </entry>
                                <entry>Polarization Rate: <mathphrase>P = sqrt(Q*Q + U*U)</mathphrase></entry>
                            </row>
                            
                            
                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_I_rel_sum</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>45</computeroutput>
                                </entry>
                                <entry>Relative Stokes parameter <mathphrase>I/sum(I(1:NBVM)), where NBVM is the total number of provided angles</mathphrase></entry>
                            </row>
                            
                            <row>
                                <entry>
                                    <computeroutput>MEAS_TYPE_P_rel</computeroutput>
                                </entry>
                                <entry>
                                    <computeroutput>46</computeroutput>
                                </entry>
                                <entry>Linear polarization <mathphrase>sqrt(Q*Q+U*U)/I</mathphrase></entry>
                            </row>

                        </tbody>
                    </tgroup>
                </table>
            </para>               
        </sect2>
        <sect2>
            <title>Angle definition</title>
            <para>
                This chapter main goal is to describe how the angles should
                be defined to be used inside of &GRASP; code. The universal spirit of &GRASP;, where 
                many different instruments coexist (from satellite to ground based measurements),
                creates challenges to define a homogeneous way of defining the angles, keeping a unique geometry.
                As it is shown in the figure <xref linkend="grasp-geometry-ref" /> &GRASP; angles are defined to be considered as "normal" for satellite reference.
            </para>
            <para>
             <figure xml:id="grasp-geometry-ref">
                <title>Definition of GRASP geometry</title>
                <imagedata fileref="figures/geometry_definition.png" scalefit="1" width="50%" contentdepth="50%" align="center" />
            </figure>
            </para>
            <para>
                Since &GRASP; angles are defined using a satellite reference, it provokes
                some problems to define what we could call as an intuitive "ground based" reference system. That is 
                why we are going to put special emphasis on the definition of the angles to these less intuitive applications.
                The intuitive reference for "ground based" measurements, in spherical geometry, is given as follows:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
&thetagb; zenith angle: with the zero established in the zenith
                    </listitem>

                    <listitem>
&phigb; azimuth angle: with the zero considered in the sun position
                    </listitem>
                </itemizedlist>
                where the sub index "gb" makes reference to "ground based".
            </para>
            <para>
                The conversion to the &GRASP; geometry is done as follows:
                <equation>
                    <title>Conversion from &thetagb; (ground based) to &thetaG; (&GRASP;)</title>
&thetaG; = 180&degree; - &thetagb;
                </equation>
                <equation>
                    <title>Conversion from &phigb; (ground based) to &phiG; (&GRASP;)</title>
&phiG; = 180&degree; + &phigb;
                </equation>
            </para>
            <para>
                Here we propose some examples for better understanding of the process. Before
                defining the measurement angles introduced in the code, both "intuitive"
                and "GRASP", we need first to consider the instrument viewing angle
                for each scenario (&thetav;, &phiv;). The following figure and table will provide
                some examples of angles defined for the ground based applications.
            </para>
            <para role="Normal">
                <figure xml:id="ground-based">
                  <title>Ground based angles definition example</title>
                  <imagedata fileref="figures/AppendixB_AngleDefinition.png" scalefit="1" width="100%" contentdepth="100%" align="center" />
                </figure>
            </para>
            <table frame="all">
                <title>Specific examples in ground based angle definition example</title>
                <tgroup cols="8" align="center" colsep="1" rowsep="1">
                    <thead>
                        <row>
                            <entry>Example</entry>
                            <entry>&thetas;</entry>
                            <entry>&thetav;</entry>
                            <entry>&phiv;</entry>
                            <entry>&thetagb;</entry>
                            <entry>&phigb;</entry>
                            <entry>&thetaG;</entry>
                            <entry>&phiG;</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>1</entry>
                            <entry>25&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>25&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>155&degree;</entry>
                            <entry>180&degree;</entry>
                        </row>
                        <row>
                            <entry>2</entry>
                            <entry>25&degree;</entry>
                            <entry>12.5&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>12.5&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>167.5&degree;</entry>
                            <entry>180&degree;</entry>
                        </row>
                        <row>
                            <entry>3</entry>
                            <entry>25&degree;</entry>
                            <entry>25&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>180&degree;</entry>
                            <entry>180&degree;</entry>
                        </row>
                        <row>
                            <entry>4</entry>
                            <entry>25&degree;</entry>
                            <entry>37.5&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>12.5&degree;</entry>
                            <entry>180&degree;</entry>
                            <entry>167.5&degree;</entry>
                            <entry>0&degree;</entry>
                        </row>
                        <row>
                            <entry>5</entry>
                            <entry>25&degree;</entry>
                            <entry>50&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>25&degree;</entry>
                            <entry>180&degree;</entry>
                            <entry>155&degree;</entry>
                            <entry>0&degree;</entry>
                        </row>
                        <row>
                            <entry>6</entry>
                            <entry>25&degree;</entry>
                            <entry>90&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>65&degree;</entry>
                            <entry>180&degree;</entry>
                            <entry>115&degree;</entry>
                            <entry>0&degree;</entry>
                        </row>
                        <row>
                            <entry>7</entry>
                            <entry>25&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>30&degree;</entry>
                            <entry>25&degree;</entry>
                            <entry>30&degree;</entry>
                            <entry>155&degree;</entry>
                            <entry>210&degree;</entry>
                        </row>
                        <row>
                            <entry>8</entry>
                            <entry>25&degree;</entry>
                            <entry>0&degree;</entry>
                            <entry>90&degree;</entry>
                            <entry>25&degree;</entry>
                            <entry>90&degree;</entry>
                            <entry>155&degree;</entry>
                            <entry>270&degree;</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                Since sunphptometers are widely used with &GRASP;, the following table provides
                information specifically about these instruments, considering the instrument 
                viewing angle for each scenario (&thetav;, &phiv;). They can be understood as the
                "movements of the motors". The process will be as follow:
            </para>
            <para>
                instrument viewing angle -> angle in (intuitive) ground based -> angle in GRASP
            </para>

            <table frame="all">
                <title>Sunphotometer angle description</title>
                <tgroup cols="8" align="center" colsep="1" rowsep="1">                   
                    <thead>
                        <row>
                            <entry>Measure type</entry> 
                            <entry>Angle</entry>
                            <entry>Inst. View.</entry>
                            <entry>Range</entry>
                            <entry>Gr. Based</entry>
                            <entry>Range</entry>
                            <entry>GRASP</entry>
                            <entry>Range</entry>
                        </row>
                    </thead>
                    <tbody>
                        <footnote id="fnmeas">
                            <para>
                                &thetas; refers to the solar zenith angle (for different measurements)
                            </para>
                        </footnote>
                        <footnote id="fndecreasing">
                            <para>
                                decreasing values
                            </para>
                        </footnote>   
                        <footnote id="fndecreasing">
                            <para>
                                decreasing values
                            </para>
                        </footnote>  
                        <footnote id="fnppl">
                            <para>
                                The data of the polarized principal plane correspond always to fixed
                                points in the sky and it is given for the instrument in so-called
                                ground based coordinates.
                            </para>
                        </footnote>   
                        <row>
                            <entry morerows='1' valign='middle'>Direct sun</entry>
                            <entry>&theta;</entry>
                            <entry>&thetav; = 0&degree;</entry>
                            <entry>[0&degree;]</entry>
                            <entry>&thetagb; = &thetas;</entry>
                            <entry>[0&degree; -- 90&degree;]<footnoteref linkend="fnmeas" /></entry>
                            <entry>&thetaG; = 180&degree; - &thetas;</entry>
                            <entry>[180&degree; -- 90&degree;]<footnoteref linkend="fnmeas" /></entry>
                        </row>
                        <row>
                            <entry>&phi;</entry>
                            <entry>&phiv; = 0&degree;</entry>
                            <entry>[0&degree;]</entry>
                            <entry>&phigb; = 0&degree;</entry>
                            <entry>[0&degree;]</entry>
                            <entry>&phiG; = 180&degree;</entry>
                            <entry>[180&degree;]</entry>
                        </row>
                        <row>
                            <entry morerows='1' valign='middle'>Almucantar</entry>
                            <entry>&theta;</entry>
                            <entry>&thetav; = 0&degree;</entry>
                            <entry>[0&degree;]</entry>
                            <entry>&thetagb; = &thetas;</entry>
                            <entry>[&thetas;]</entry>
                            <entry>&thetaG; = 180&degree; - &thetas;</entry>
                            <entry>[180&degree; -- &thetas;]</entry>
                        </row>
                        <row>
                            <entry>&phi;</entry>
                            <entry>&phiv; = 3&degree;, 3.5&degree;, 4&degree;, 5&degree;, ...,
                                90&degree;, ... 180&degree;</entry>
                            <entry>[0&degree; - 180&degree;]</entry>
                            <entry>&phigb; = 3&degree;, 3.5&degree;, 4&degree;, 5&degree;, ...,
                                90&degree;, ... 180&degree;</entry>
                            <entry>[0&degree; -- 180&degree;]</entry>
                            <entry>&phiG; = 183&degree;, 183.5&degree;, 184&degree;,
                                185&degree;, ... 270&degree;, ... 360&degree;</entry>
                            <entry>[180&degree; -- 360&degree;]</entry>
                        </row> 
                        <row>
                            <entry morerows='1' valign='middle'>
                                   Principal plane measurement: Before the zenith  
                            </entry>   
                            <entry>&theta;</entry>
                            <entry>&thetav; = -6&degree;, ... , -3&degree;, 3&degree;, &thetamax; &lt; &thetas; </entry>
                            <entry>[-6&degree; -- (&thetamax; &lt; &thetas;)]</entry>
                            <entry>&thetagb; = &thetas; + 6&degree; ... &thetas; + 3&degree;, &thetas; - 3&degree;, ... &thetas; - 6&degree;, &thetas; - &thetamax;</entry>
                            <entry>[(&thetas; + 6&degree;) -- 0]<footnoteref linkend="fndecreasing" /></entry>
                            <entry>&thetaG; = 180&degree; - &thetas; - 6&degree;, ... 
                                180&degree; - &thetas; - 3&degree;,
                                180&degree; - &thetas; + 3&degree;, ...
                                180&degree; - &thetas; + &thetamax;
                            </entry>
                            <entry>[(180&degree; - &thetas; - 6&degree;) -- 180&degree;]</entry>
                        </row>
                        <row>
                            <entry>&phi;</entry>
                            <entry>&phiv; = 0&degree;</entry>
                            <entry>[0&degree;]</entry>
                            <entry>&phigb; = 0&degree;</entry>
                            <entry>[0&degree;]</entry>
                            <entry>&phiG; = 180&degree;</entry>
                             <entry>[180&degree;]</entry>
                        </row>         

                        <row>
                            <entry morerows='1' valign='middle'>Principal plane measurement: After the zenith </entry>   
                            <entry>&theta;</entry>
                            <entry>&thetav; = &thetamin; &lt; &thetas; , ... 140&degree; or &thetamax; - &thetas; &gt; 90&degree;</entry>
                            <entry>[(&thetamin; &lt; &thetas;) -- 140&degree;]</entry>
                            <entry>&thetagb; = &thetamin; - &thetas; ... 140&degree; - &thetas; or &thetamax; - &thetas;</entry>
                            <entry>[0&degree; -- 90&degree;]<footnoteref linkend="fndecreasing" /></entry>
                            <entry>&thetaG; = 180&degree; + &thetas; - &thetamin;, ... 
                                180&degree; + &thetas; - 140&degree;
                                or 180&degree; + &thetas; - &thetamax;
                            </entry>
                            <entry>[180&degree; -- 90&degree;]<footnoteref linkend="fndecreasing" /></entry>
                        </row>
                        <row>
                            <entry>&phi;</entry>
                            <entry>&phiv; = 0&degree;</entry>
                            <entry>[180&degree;]</entry>
                            <entry>&phigb; = 180&degree;</entry>
                            <entry>[180&degree;]</entry>
                            <entry>&phiG; = 0&degree;</entry>
                            <entry>[0&degree;]</entry>
                        </row>      
                        <row>
                            <entry morerows='1' valign='middle'>Polarized principal plane measurement:
                    before the zenith<footnoteref linkend="fnppl" /></entry>   
                            <entry>&theta;</entry>
                            <entry></entry>
                            <entry></entry>
                            <entry>&thetagb; = 85&degree;, 80&degree;, 75&degree;, ...
                                10&degree;, 5&degree;, 0&degree;</entry>
                            <entry></entry>
                            <entry>&thetaG; = 95&degree;, 100&degree;, 105&degree;, ...
                                170&degree;, 175&degree;, 180&degree;</entry>
                            <entry></entry>
                        </row>
                        <row>
                            <entry>&phi;</entry>
                            <entry></entry>
                            <entry></entry>
                            <entry>&phigb; = 0&degree;</entry>
                            <entry></entry>
                            <entry>&phiG; = 180&degree;</entry>
                            <entry></entry>
                        </row> 

                        <row>
                            <entry morerows='1' valign='middle'>Polarized principal plane measurement:
                    after the zenith<footnoteref linkend="fnppl" /></entry>   
                            <entry>&theta;</entry>
                            <entry></entry>
                            <entry></entry>
                            <entry>&thetagb; = 0&degree;, 5&degree;, 10&degree;, ...
                                75&degree;, 80&degree;, 85&degree;</entry>
                            <entry></entry>
                            <entry>&thetaG; = 180&degree;, 175&degree;, 170&degree;, ...
                                105&degree;, 100&degree;, 95&degree;</entry>
                            <entry></entry>
                        </row>
                        <row>
                            <entry>&phi;</entry>
                            <entry></entry>
                            <entry></entry>
                            <entry>&phigb; = 180&degree;</entry>
                            <entry></entry>
                             <entry>&phiG; = 0&degree;</entry>
                            <entry></entry>
                        </row>                                                                                                                                                                                                                               
                    </tbody>
                </tgroup>
            </table>
            
            <para>
                In the case of nephelometer data angle definition, it is a bit different since only &theta; angle has to be defined, the rest of the angles
                will be ignored. To provide nephelometer data (phase matrix), the conversion to the &GRASP; geometry is done as follows:
                <equation>
                    <title>Conversion from &thetan; (nephelometer scattering angle) to &thetaG; (&GRASP;)</title>
                    &thetaG; = 180&degree; - &thetan;
                </equation>
            </para>
           
        </sect2>
        
        <sect2 id="input_infor_char">
            <title>Input information for characteristics</title>
            <para>
                While in many cases the input data is just represented by SDATA information, sometimes it is necessary to provide extra information for each pixel. The way to inject extra information to the algorithm is to do it through the initial guess. Sometimes, this is just because the user wants to provide different initial guesses for each pixel, or sometimes it is just input information. In the first case, this can be easily done by the imagedat files that will be described below. On the other hand, when a charactacteristic is defined  as “retrieved=false”, it is taken as input information.
            </para>
            <para>
                The “segment_imagedat” tool  enables the user to provide an ASCII file containing the complete set of initial guesses for all the pixels. Following illustration is an example of how the imagedat files looks like:
            </para>
            <para role="Normal">
              <figure xml:id="segment_imagedat_exaple">
                <title>Example of a possible use of imagedat</title>
                <imagedata fileref="figures/segment_imagedat_exaple.png" scalefit="1" width="100%" contentdepth="100%" align="center" />
              </figure>
            </para>
            <para>
                The columns in this ASCII file correspond to the pixels, and each row is associated with a different characteristic. The first column is just the enumeration of characteristics starting by 1. The total number of both columns and rows has to be consistent with the input file. The value “-999” can be assigned to the initial guesses which the user does not need to modify, in this case the value defined in the characteristics section of the settings file will be taken by default.  This mechanism provides a very versatile tool to inject pixel-dependent data to the retrieval code, for adjusting the initial guess or just for providing external input information from climatologies, models, etc.
            </para>
        </sect2>
    
        <sect2>
            <title>How to prepare the photometer data</title>
            <para>
                Sunphotometers are widely used with &GRASP;. They take measurements of sky radiance and direct sun. Many inversion strategies can
                be used to retrieve sunphotometer data, but this section will explain how to define input data. The information that runs inside of 
                &GRASP; has to be pre-processed in order to screen clouds, calibrate and normalize the data.
            </para>
            <para>
                Following <xref linkend="sdata-format" />, the direct sun measurements can be described as AOD or TOD  defined in <xref linkend="tabletypesmeasurements" />
                as measurements of type 11 or 12. At this point it is needed to take into account that if "ifgas" field is defined as 1 in the case of AOD, no gaseous absorption optical depth will be accounted, but in the case of TOD they will be subtracted. The gases also affect the radiance measurements but in lower magnitude.
                In the case of TOD + radiances with ifgas=1, the same model will be applied to all measurements. If AOD is used, some (minor) incongruences could come from the use of different models to calculate gases for AOD and for radiances.
            </para>
            <para>
                Radiance measurements are defined with the constant MEAS_TYPE_I(41). Polarized measurements can be defined as Q,U (42, 43) or as polarization rate (44). It is also important to check how polarized data is going to be manipulated in the retrieval code based on inversion strategy defined in the settings file.
            </para>
        </sect2>
        <sect2>
            <title>How to prepare the lidar data</title>
                <para>
                    Note that all processing will be considering range corrected profile for one wavelength. 
                    The procedure for other profiles from different wavelengths are exactly the same. 
                    Range corrected profile implies that at least the background noise was subtracted and altitude corrections were applied to the
                    raw signal, but if it's possible to consider all other corrections (electrical noise and overlap
                    correction, dead time correction, gluing analog and photon-counting signals and all 
                    others that your system may have), you should apply them.
                </para>
                <para>
                    <emphasis role="bold">
                        Step 1. Background noise subtraction and range correction.
                    </emphasis>
                </para>
                <para>
                    Let <emphasis role="bold">B'</emphasis> be the estimation of the background noise.
                    Usually <emphasis role="bold">B'</emphasis> is estimated as 
                    <emphasis role="bold">P(Z<subscript>B</subscript>)</emphasis>, accumulated and averaged 
                    around selected altitude <emphasis role="bold">Z<subscript>B</subscript>Z</emphasis>, 
                    much higher than the maximum altitude of lidar extraction in step 2 (<emphasis role="bold">Z<subscript>max</subscript></emphasis>).
                    For example with maximum altitude <emphasis role="bold">Z<subscript>max</subscript>=15km</emphasis>, 
                    it is averaged around 30 km and accumulated for the whole period of lidar observation.
                    The noise and range corrected signal will be:
                 </para>
                 <para>
                    <emphasis role="bold">
                       S(Z<subscript>i</subscript>) = (P(Z<subscript>i</subscript>)-B')*Z<subscript>i</subscript><superscript>2</superscript>
                    </emphasis>
                </para>
                <para>
                    <emphasis role="bold">
                        Step 2. Altitude range selection and signal cropping.
                    </emphasis>
                </para>
                <para>
                    The minimum <emphasis role="bold">Z<subscript>min</subscript></emphasis> and maximum
                    <emphasis role="bold">Z<subscript>max</subscript></emphasis> altitudes are selected and the signal 
                    is cropped, so <emphasis role="bold">Z<subscript>min</subscript>&lt;Z<subscript>i</subscript>&lt;Z<subscript>max</subscript></emphasis>.
                    The minimum altitude should be selected as low as possible, preferably in the region where the overlap 
                    correction could be correctly applied. The <emphasis role="bold">Z<subscript>max</subscript></emphasis> should be 
                    selected from the following considerations: maximum altitude where the noise levels of lidar measurement are 
                    acceptable and the amount of atmospheric aerosols is still noticeable.
                </para>
                <para>
                <emphasis>
                    In case if the lidar used is inclined
                </emphasis>
                    The sounding zenith angle should be provided for the corresponding wavelenghts. The angle value should be placed in the position of the SZA corresponding to this wavelength.
                    All SZA's for all vertical profile measurements should be the same.
                    Vertically pointed lidar should have this value set to 0.
                    <emphasis>
                        Note: Keep in mind that retrieved aerosol vertical profiles will be retrieved for vertically projected altitudes,
                        i.e. if your lidar is inclined, the maximum altitude of the profile will be equivalent to
                        <emphasis role="bold">Z<subscript>max</subscript>*cos(SZA)</emphasis>.
                    </emphasis>
                </para>
                <para>
                    <emphasis role="bold">
                        Step 3. Backscatter of molecular profile
                    </emphasis>
                </para>
                <para>
                    Backscatter vertical profile is calculated inside of GRASP based on
                    standard atmosphere model for each lidar wavelength[1]:
                </para>
                <para>
                    <emphasis role="bold">
                        &beta;<subscript>mol</subscript>(Z<subscript>i</subscript>,&lambda;) =
                        N * &sigma;(&lambda;) * (P(Z<subscript>i</subscript>)/P<subscript>SA</subscript>)
                        * (T<subscript>SA</subscript>/T(Z<subscript>i</subscript>))
                    </emphasis>
                </para>
                <para>        
                    where:
                    <itemizedlist>
                        <listitem>
                            <emphasis role="bold">N </emphasis>molecular number density
                        </listitem>  
                        <listitem>
                            <emphasis role="bold">&sigma;(&lambda;) </emphasis> total Rayleigh cross section per molecule,
                            which analytical formula can be written like 
                            <emphasis role="bold">
                                &sigma;(&lambda;) = A * &lambda; <superscript>-B-C*&lambda;-D/&lambda;</superscript>
                            </emphasis>
                        </listitem>  
                        <listitem>
                            <emphasis role="bold">P<subscript>sa</subscript></emphasis> pressure of standard atmosphere model
                        </listitem>
                        <listitem>
                            <emphasis role="bold">T<subscript>sa</subscript></emphasis> temperature of standard atmosphere model
                        </listitem>
                        <listitem>
                            <emphasis role="bold">P(Z<subscript>i</subscript>)</emphasis> pressure profile of atmosphere
                        </listitem>
                        <listitem>
                            <emphasis role="bold">T(Z<subscript>i</subscript>)</emphasis> temperature profile of atmosphere
                        </listitem>
                    </itemizedlist>
                </para>

                <para>
                    <emphasis role="bold">
                        Step 4. Reducing the number of points in profiles
                    </emphasis>
                </para>
                
                <para>
                    GRASP/GARRLiC can use arbitrary altitude/range scale. However, to keep number of retrieved parameters reasonable
                    and to fight higher noise contamination of lidar signals at higher altitudes, it is recommended to
                    use a logarithmical altitude/range scale with <emphasis role="bold">N<subscript>Z</subscript></emphasis>
                    points to represent aerosol profiles in the atmosphere. For that, we have to present all vectors (altitude/range
                    vector and profiles of lidar signals) in logarithmically equidistant manner.
                </para>
                <para>
                    1. Move to logarithmic scale and find altitude/range step:
                </para>
                <para>
                    logarithmic scale: 
                    <emphasis role="bold">
                        Z<subscript>i</subscript>
                        <superscript>lg</superscript> = lg(Z<subscript>i</subscript>) 
                    </emphasis> 
                </para>
                <para>
                    step in log scale:
                    <emphasis role="bold">
                        &Delta;Z = (Z<subscript>max</subscript>
                        <superscript>lg</superscript> - Z<subscript>min</subscript><superscript>lg</superscript>)/N<subscript>Z</subscript>
                    </emphasis> 
                </para>
                <para>
                    logarithmic altitude ranges (from 
                    <emphasis role="bold">
                        h<subscript>k</subscript>
                    </emphasis> 
                    to
                    <emphasis role="bold">
                        h<subscript>k+1</subscript>
                    </emphasis>                      
                    ) for averaging data in logarithmically equidistant manner, k = 1 .. N<subscript>z</subscript>:
                    <emphasis role="bold">
                        h<subscript>k</subscript> = Z<subscript>0</subscript>
                        <superscript>lg</superscript> + (k - 1) * &Delta;Z
                    </emphasis>
                </para>
  
                <para>
                    2. Average the data profiles
                </para>
  
                <para>
                    <emphasis role="bold">
                        A<subscript>k</subscript> = (&Sigma;<subscript>j=1</subscript><superscript>n</superscript>
                        A<subscript>j</subscript>(h<subscript>k</subscript>, h<subscript>k+1</subscript>) ) / n
                    </emphasis>
                </para>
                
                <para>       
                    where: 
                    <itemizedlist>
                        <listitem>
                            <emphasis role="bold">A</emphasis> altitude vector or profile of lidar signal or molecular backscatter
                        </listitem>
                        <listitem>
                            <emphasis role="bold">n</emphasis> number of points inside logarithmic altitude ranges
                        </listitem>
                    </itemizedlist>
                </para>
  
                <para>
                    After such procedure, the number of points in three main vectors reduced to N<subscript>Z</subscript>
                    points in logarithmically equidistant manner.
                    These values should be placed in places corresponding to the zenith wieving (&vza; or &thetav;) angles for the vavelenths corresponding to lidar or vertical measurements.
                </para>
  
                <para>
                    <emphasis>
                        Hint: the altitude/range vectors for measurements at all wavelengths have to be the same.
                    </emphasis>
                </para>

  
                <para>
                    <emphasis role="bold">
                        Step 5. Profile normalization
                    </emphasis>
                </para>
  
                <para>
                    Values of lidar signals (except for volume depolarization profiles) vary from instrument to instrument, from detector to detector, that is why GRASP/GARRLiC requires normalized lidar signal.
                    For consistency with the molecular optical depth, the profile of the molecular backscatter inside the code has to be normalized as well.
                    Normalized lidar and backscatter profiles:
                </para>
  
                <para>
                    <emphasis role="bold">
                        A'<subscript>k</subscript> = A<subscript>k</subscript> / &int;<subscript>Zmin</subscript><superscript>Zmax</superscript>
                        A<subscript>k</subscript> dZ
                    </emphasis>
                </para>

                <para>        
                    where <emphasis role="bold">A</emphasis> represents profile of lidar signal or molecular backscatter.
                </para>
                <para>
                    <emphasis>
                        Caution: integration have to be done using meters in altitudes.
                    </emphasis>
                </para>
                <para>
                    At the end, for each wavelength you have to have normalized lidar profiles and altitude vector.
                    Volume depolarization profiles don't need to be normalized, the only requirement for such observations is to be presented in the percentage range i.e. [1.0e-9, 100]
                </para>
                <para>
                    <emphasis>
                        References: Anthony Bucholtz, Rayleigh-scattering calculations for the terrestrial atmosphere, Optical Society of America, 1995.
                    </emphasis>
                </para>
        </sect2>

        <sect2>
            <title>How to prepare nephelometer data</title>

            <para>
                    &GRASP; is able to retrieve and simulate nephelometer measurements.
                    This section is devoted to the definition of the convention to properly account the units and measurement geometry of these instruments within &GRASP; standards. 
            </para>
            <para>
                    The zero reference of scattering angles in &GRASP; is 180 &degree;. 
                    Thus, in order to introduce the nephelometer geometry in &GRASP; sdata, only &theta; angle (zenith angle) has to be defined, the rest of the angles will be ignored. The conversion to the &GRASP; geometry is done as follows:
            </para>
            <emphasis role="bold">
                    &thetaG; = 180&degree; - &thetan;
            </emphasis>
            <para>
                   Where &thetaG; corresponds to sdata angles and &thetan; to the scattering angles of the nephelometer.
            </para>
            <para>
                   &GRASP; measurement input corresponds to the normalized Phase Matrix element P<subscript>1,1</subscript>, and the relation with scattering function is described below.
            </para>
            <para>
                   &GRASP; scattering phase function units are: 
            </para>
            <emphasis role="bold">
                    [F<subscript>1,1</subscript>(&lambda;, &Theta;)] = 1/&mu;m
            </emphasis>
            <para>
                   &GRASP; scattering phase function units are: 
            </para>
            <emphasis role="bold">
                   [&sigma;] = 1/&mu;m
            </emphasis>
            <para>
                   The relationship between both is represented by the following expression: 
            </para>
            <emphasis role="bold">
                   &sigma; = (1/2) * &int;<superscript>&pi;</superscript><subscript>0</subscript> F<subscript>1,1</subscript>(&lambda;, &Theta;) * sin( &Theta;) d &Theta;
            </emphasis>
            <para>
                   Which means that the normalized Phase Matrix element P<subscript>1,1</subscript> is defined as:
            </para>
            <emphasis role="bold">
                   (1/2) * &int;<superscript>&pi;</superscript><subscript>0</subscript> P<subscript>1,1</subscript>(&lambda;, &Theta;) * sin( &Theta;) d &Theta; = 1
            </emphasis>
            <emphasis role="bold">
                   P<subscript>1,1</subscript>(&lambda;, &Theta;) = F<subscript>1,1</subscript>(&lambda;, &Theta;)/&sigma;
            </emphasis>
            <para>
                   If polar neph measurements are used, an additional factor of  4* &pi; is necessary to convert into the units in &GRASP;: &mu;m-1Str-1 to &mu;m-1.
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Output module</title>  
        <para>
            The output module is responsible for managing results for each segment or entire tile and driving them to the correspond destination (file or screen).
            There are two kinds of main output structure into &GRASP;: tile and segment. Segment output structure represents the output results obtained from the retrieval library. Then, core unit compacts it and stores it in a tile output structure, which contains the results of the entire process.
        </para>
        <para>
            Output module can be extended in the same way as input module. In the case of the output there are three kinds of extensions:
            <itemizedlist>
                <listitem>
                    <emphasis role="bold">output segment function: </emphasis> it is called after retrieving a segment and is called with the results of that single segment.
                </listitem>
                <listitem>
                    <emphasis role="bold">output current function: </emphasis> it is called after retrieving each segment but it is called with the partial tile processed until that moment. In each call to this function, it gets a partial tile nearest to completion. Last call to that function will send the entire tile results.
                </listitem>
                <listitem>
                    <emphasis role="bold">output tile function: </emphasis> at the end of the process, a function is called sending to it the entire tile results. It can print a complete map of the process.
                </listitem>
            </itemizedlist>
        </para>
        <para>
            As the user can see, &GRASP; is very flexible in the way to work with the output. In a high optimized process, it can be adapted directly to the format of the output database. By default, &GRASP; comes with some ASCII output functions, which allows to print the results in a readable way (ASCII or specific &GRASP; format), into a file (using
            stream library) or on the screen. Additional extensions can be added to get the output in different formats such us HDF, NetCDF, png plots...
        </para>
        <sect2 id="grasp-output">
            <title>The list of &GRASP; output parameters</title>
            <para>
                The output from &GRASP; is quite complex and strongly dependent on the settings used. As it was discussed in <xref linkend="sect-iguess" />,
                there are two kinds of output products: direct and derived. Direct results are the values directly inverted in the initial guess array, then
                after obtaining them, forward model is called one more time to obtain the derived products. The list of direct and derived products obtained 
                depends on the data and the inversion strategy selected (defined in the settings file). This chapter contains a complete list of products that can
                be obtained with &GRASP;, but it does not mean that all of them can be obtained with all inversion strategies.
            </para>
            <para>
                In the internal &GRASP; output structures there are some products that are repeated between direct products structure (array with the
                same shape as initial guess) and derived products. The reason is that for some applications they are direct information, for others they are derived results. 
                This depends on input data and inversion strategy, defined in the settings file.
            </para>   
            <para>
                Before defining the output, we are going to define the size of some arrays. This information is needed to understand the list of the products.
                For example, when a product such as AOD is defined as many times as wavelengths, it is because the output will be wavelength dependent 
                (a value for each wavelength):
                <itemizedlist>
                    <listitem>
                        <emphasis role="bold">NW: </emphasis>Number of wavelengths
                    </listitem>                      
                    <listitem>
                        <emphasis role="bold">NSD: </emphasis>Number of aerosol components
                    </listitem>
                    <listitem>
                        <emphasis role="bold">NKNOISE: </emphasis>Number of noises defined
                    </listitem>  
                    <listitem>
                        <emphasis role="bold">NPARS: </emphasis>Number of parameters to be retrieved
                    </listitem>
                                                       
                </itemizedlist>           
            </para>             

            <para>
                The following list includes all products that can be obtained using &GRASP;:
                <itemizedlist>
                    <listitem>Number of iterations (niter)</listitem>
                    <listitem>Total final measurement fitting residual for multi-pixel retrieval (rest)</listitem>
                    <listitem>Detailed (i.e., separated by the type of observation) final absolute measurement fitting residuals for segment (resat)</listitem>
                    <listitem>Detailed (i.e., separated by the type of observation) final relative measurement residuals for segment (resrt)</listitem>
                    <listitem>If SD (size distribution) retrieved in form of binned SD, the number of grid radii for SD (used to print output) (radius)</listitem>
                    <listitem>If SD retrieved in form of binned SD, grid radii</listitem>
                    <listitem>If the pre-calculated lognormal bins where used, the
                        function describing each lognormal SD bin (used to print output) (SDL)</listitem>
                    <listitem>Main output for each single pixel (for both single- and multiple-pixel retrievals):
                        <itemizedlist>
                            <listitem>Single pixel total residual (meas. + smoothness constraints) (res)</listitem>
                            <listitem>Detailed absolute measurement residuals (resa[NKNOISE])</listitem>
                            <listitem>Detailed relative measurement residuals (resr[NKNOISE])</listitem>
                            <listitem>Retrieved aerosol and surface reflectance parameters (par[NPARS])</listitem>
                            <listitem>Angstrom exponent (Aexp)</listitem>
                            <listitem>For each wavelength:
                                <itemizedlist>
                                    <listitem>Spectral total aerosol extinction (extt)</listitem>
                                    <listitem>Spectral total aerosol single scattering albedo (ssat)</listitem>
                                    <listitem>Spectral total aerosol absorption extinction (aext)</listitem>
                                </itemizedlist>
                                If retrieved aerosol consist of several components:
                                <itemizedlist>
                                    <listitem>Spectral extinction for each component (ext[NSD])</listitem>
                                    <listitem>Spectral single scattering albedo for each component (ssa[NSD])</listitem>
                                    <listitem>Real part of refractive index for each aerosol component (mreal[NSD])</listitem>
                                    <listitem>Imaginary part of refractive index for each component(mimag[NSD])</listitem>
                                </itemizedlist>
                            </listitem>
                        </itemizedlist>
                    </listitem>
	
                    <listitem>If SD retrieved in form of binned SD, the optical properties can be calculated for fine and coarse modes, separated using chosen inflection radii:
                        <itemizedlist>
                            <listitem>Volume median radius (rv)</listitem>
                            <listitem>Standard deviation (std)</listitem>
                            <listitem>Concentration (cv)</listitem>
                            <listitem>Effective radius (reff)</listitem>
                            <listitem>Spectral extinction for each wavelength (ext[NW])</listitem>
                        </itemizedlist>
                    </listitem>
	
                    <listitem>Phase matrix parameters:
                        <itemizedlist>
                            <listitem>Number of scattering angles (nangle)</listitem>
                            <listitem>Values of scattering angles (angles)</listitem>
                            <listitem>For each pixel and for all the wavelengths:
                                <itemizedlist>
                                    <listitem>Phase matrix elements for each aerosol component ph11, ph12, ph22, ph33, ph34, ph44</listitem>
                                    <listitem>Total aerosol phase matrix elements pht11, pht12, pht22, pht33, pht34, pht44</listitem>
                                    <listitem>Lidar and depolarization ratios for each aerosol component (lr, dlpr)</listitem>
                                    <listitem>Total aerosol lidar and depolarization ratios (lrt, dlprt)</listitem>
                                </itemizedlist>
	    
                            </listitem>
                        <listitem>Phase matrix norm. The analytical expresion used to calculate the norm is:
                            <para>
                                 Norm = (1/2) * &int;<superscript>&pi;</superscript><subscript>0</subscript> P<subscript>1,1</subscript>(&lambda;, &Theta;) * sin( &Theta;) d &Theta;
                            </para>
                            However, in order to achieve an optimal degree of accuracy it is recomended to perform this integration trought the Simpson rule with 721 bins in the logaritmic space.
                        </listitem>
                        <listitem>Asymmetry parameter. The analytical expresion used to calculate this magnitude is:
                            <para>
                                 &lt; cos( &Theta;) &gt; = (1/2) * &int;<superscript>&pi;</superscript><subscript>0</subscript> P<subscript>1,1</subscript>(&lambda;, &Theta;) * sin( &Theta;) * cos( &Theta;) d &Theta;
                            </para>
                            It is recomended to perform the numerical calculation of the integral analogously to the case of the phase matrix norm.
                        </listitem>
                        </itemizedlist>
                    </listitem>
	
                    <listitem>If chemical composition is retrieved, then for each pixel and each aerosol component:
                        <itemizedlist>
                            <listitem>Relative humidity (rh(NSD))</listitem>
                            <listitem>Fraction of soluble (fslbl(NSD))</listitem>
                            <listitem>Insoluble fractions of soot (fsoot(NSD))</listitem>
                            <listitem>Insoluble fractions of iron (firon(NSD))</listitem>
                            <listitem>Insoluble fractions of “quartz” (fslbl(NSD))</listitem>
                            <listitem>Water fraction (fwtr(NSD))</listitem>
                        </itemizedlist>
                    </listitem>
	
                    <listitem>Surface reflectance parameters for each pixel and for each wavelength:
                        <itemizedlist>
                            <listitem>All parameters of BRDF</listitem>
                            <listitem>All parameters of BPRDF</listitem>
                            <listitem>Surface Albedo</listitem>
                        </itemizedlist>
                    </listitem>
	
                    <listitem>Lidar characteristics for each pixel:
                        <itemizedlist>
                            <listitem>Levels for vertical profiles</listitem>
                            <listitem>Vertical profiles for retrieved aerosol components (avp(NSD))</listitem>
                        </itemizedlist>
                    </listitem>
	
                    <listitem>Lidar optical characteristics for each pixel and for each wavelength:
                        <itemizedlist>
                            
                        <listitem>Aerosol extinction profiles (&sigma;<subscript>aer</subscript>(&#x3BB;, h)). In order to obtain this magnitude from the variables in the standard &GRASP; output file, the column aerosol optical depth just needs to be weighted by the normalized aerosol vertical profile for each mode.
                            <para>
                            &sigma;<subscript>aer,i</subscript>(&lambda;, h) =  &tau;<subscript>i</subscript> * avp<subscript>i</subscript>(h)
                            </para>
                            
                            <para>
                            If two or more aerosol modes are included, the total extinction profile can be obtained adding up all profiles.
                            </para>
                            <para>
                            &sigma;<subscript>aer</subscript>(&lambda;, h) = &Sigma;<subscript>i=1</subscript><superscript>n</superscript> &tau;<subscript>i</subscript> * avp<subscript>i</subscript>(h)
                            </para>
                            </listitem>
                            
                        <listitem>Aerosol backscatter profiles (&beta;<subscript>aer</subscript>(&lambda;, h)). To obtain this magnitude it is only necessary to divide the aerosol extinction profile of each mode by its corresponding Lidar ratio.
                            <para>
                            &beta;<subscript>aer</subscript>(&lambda;, h) = &Sigma;<subscript>i=1</subscript><superscript>n</superscript> &sigma;<subscript>aer,i</subscript>(&lambda;, h) / S<subscript>i</subscript>(&lambda; )
                            </para>
                            </listitem>
                            
                         <listitem>Aerosol absorption profiles (&sigma;<subscript>aer</subscript><superscript>abs</superscript>(&lambda;, h)). In order to obtain this magnitude from the variables in the standard &GRASP; output file, the column aerosol absorption optical depth (&tau;<subscript>i</subscript><superscript>abs</superscript>) just needs to be weighted by the normalized aerosol vertical profile for each mode.
                            <para>
                            &sigma;<subscript>aer</subscript><superscript>abs</superscript>(&lambda;, h) = &Sigma;<subscript>i=1</subscript><superscript>n</superscript> &tau;<subscript>i</subscript><superscript>abs</superscript> * avp<subscript>i</subscript>(h)
                            </para>
                            </listitem>
                            
                            
                            <listitem>SSA profiles (&omega;<subscript>0</subscript>(&lambda;, h)). Once all the previous described magnitudes has been calculated the calculation of SSA profiles is inmidiate:
                                <para>
                                </para>
                                 <para>
                                &omega;<subscript>0</subscript>(&lambda;, h)  = &sigma;<subscript>aer</subscript><superscript>scat</superscript>(&lambda;, h) / &sigma;<subscript>aer</subscript>(&lambda;, h) = (&sigma;<subscript>aer</subscript>(&lambda;, h) - &sigma;<subscript>aer</subscript><superscript>abs</superscript>(&lambda;, h)) / &sigma;<subscript>aer</subscript>(&lambda;, h)
                                 </para>
                                </listitem>
                            <listitem>Lidar ratio profiles (S(&lambda;, h)):
                                <para>
                                </para>
                                <para>
                                 S<subscript>aer</subscript>(&lambda;, h)  = &sigma;<subscript>aer</subscript>(&lambda;,  h) / &beta;<subscript>aer</subscript>(&lambda;, h)
                                </para>
                                </listitem>
                          <listitem>Phase matrix (P<subscript>j, k</subscript>(&lambda;, &Theta;, h)):
                                <para>
                                </para>
                                <para>
                          P<subscript>j,k</subscript>(&lambda;, &Theta;, h)  = &Sigma;<subscript>i=1</subscript><superscript>n</superscript> P<subscript>j,k</subscript><superscript>i</superscript>(&lambda;, &Theta;) &sigma;<subscript>aer,i </subscript><superscript>scat</superscript>(&lambda;, h) / &sigma;<subscript>aer</subscript><superscript>scat</superscript>(&lambda;, h)
                               </para>
                          </listitem>
                          <listitem>Lidar depolarization profiles (&delta;(&lambda;, h)):
                                <para>
                                </para>
                                <para>&delta;(&lambda;,h) = (P<subscript>1,1</subscript>(&lambda;, 180&#176;, h) - P<subscript>2,2</subscript>(&lambda;, 180&#176;, h)) / (P<subscript>1,1</subscript>(&lambda;, 180&#176;, h) + P<subscript>2,2</subscript>(&lambda;, 180&#176;, h))
                                </para>
                            </listitem>
                            <listitem>Retrieved lidar calibration coefficients (for lidar wavelength only)</listitem>
                        </itemizedlist>
                    </listitem>
	
                    <listitem>Fit of every measured characteristic for each pixel and for each wavelength</listitem>
	
                    <listitem>Error estimation for each pixel:
                        <itemizedlist>
                            <listitem>Standard deviations of the random errors of the retrieved parameter logarithms (~relative errors) (ERRP)</listitem>
                            <listitem>Standard deviation of systematic errors of the retrieved parameter logarithms (BIASP)</listitem>
                            <listitem>Standard deviations of the random errors of the retrieved extinction for each aerosol component (~relative errors) (ERR_ext)</listitem>
                            <listitem>Standard deviations of systematic errors of the retrieved extinction for each aerosol component (BIAS_ext)</listitem>
                            <listitem>Standard deviations of the random errors of the retrieved total extinction (~relative errors) (ERR_extt)</listitem>
                            <listitem>Standard deviations of systematic errors of retrieved total extinction (BIAS_extt)</listitem>
                            <listitem>Standard deviations of the random errors of the retrieved single scattering albedo for each aerosol component (~relative errors) (ERR_ssa)</listitem>
                            <listitem>Standard deviations of systematic errors of retrieved single scattering albedo for each aerosol component  (BIAS_ssa)</listitem>
                            <listitem>Standard deviations of the random errors of the of retrieved total single scattering albedo (~relative errors) (ERR_ssat)</listitem>
                            <listitem>Standard deviations of systematic errors of the retrieved total single scattering albedo (BIAS_ssat)</listitem>
                            <listitem>Standard deviations of the random errors of the of retrieved lidar ratio for each aerosol component  (ERR_lr)</listitem>
                            <listitem>Standard deviations of systematic errors of the lidar ratio for each aerosol component  (BIAS_lr)</listitem>
                            <listitem>Standard deviations of the random errors of the of retrieved depolarization ratio for each aerosol component  (ERR_dr)</listitem>
                            <listitem>Standard deviations of systematic errors of the depolarization ratio for each aerosol component  (BIAS_dr)</listitem>
	  
                        </itemizedlist>
                    </listitem>
	
                    <listitem>Radiative forcing for each pixel:
                        <itemizedlist>
                            <listitem>The heights for forcing output (HLV)</listitem>
                            <listitem>Broad band up-ward flux without aerosol at each height (BBUFX0)</listitem>
                            <listitem>Broad band down-ward flux without aerosol at each height (BBDFX0)</listitem>
                            <listitem>Broad band up-ward flux with aerosol at each height (BBUFXA)</listitem>
                            <listitem>Broad band down-ward flux with aerosol at each height (BBDFXA)</listitem>
                        </itemizedlist>
                    </listitem>
	
                    <listitem>Estimations of aerosol particulate matter at the ground level (PM)</listitem>
                    <listitem>Aerosol type for each pixel (requires that the optical properties 
                        for fine and coarse modes are included in the calculated output)
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>
        <sect2 id="grasp-classic-output-description">
            <title>&GRASP; classic output description</title>
            <para>
                In this section the &GRASP; classic output format is going to be described for both if the output.segment.stream setting parameter has been set to "screen", in this case all output information will be printed on terminal; or alternatively if a path to an ascii file is provided. However, note that there are more possibilities of &GRASP; output formatting which can differ from what is going to be shown here.
            </para>
            <para>
                The &GRASP; classic output is divided in three main sections:
                <itemizedlist>
                    <listitem>Information of the residuals.
                        <para>
                        This information is place in the head of the classic output. It contains one line per pixel with information about convergence and residuals after the last iteration. The first float number in each of these lines corresponds to the absolute value of the total inversion residual of the corresponding pixel. Then, the absolute and relative residuals for each noise type defined in settings can be found.
                        </para>
                        <figure>
                            <title>An example of the residual information in &GRASP; classic output</title>
                            <screen>
                                <?db-font-size 70% ?>
      noise  abs         rel      noise  abs        rel
0.358 1:     0.777E-03   0.262 %  2:     0.317E-03  0.115 %   pixel # 1  Residual after iteration # 21
0.288 1:     0.124E-03   0.425 %  2:     0.341E-03  0.155 %   pixel # 2  Residual after iteration # 17
                                   
                            </screen>
                        </figure>
                        <para>
                        After the residuals, the information of date, time, longitude and latitude of each pixel can be found.
                        </para>
                        <para>
                        The next part of the output is a list of all the retrieved parameters as they are calculated in the inversion matrix, each column is associated with a different pixel.
                        </para>
                        <figure>
                            <title>An example of the vector of retrieved parameters in &GRASP; classic output</title>
                            <screen>
                                <?db-font-size 70% ?>
                                Parameter #, Vector of retrieved parameters
                                1    0.31000E-03    0.21000E-03
                                2    0.38939E-02    0.89239E-02
                                3    0.19772E-01    0.13772E-01
                                4    0.45246E-01    0.55232E-01
                                5    0.50813E-01    0.68823E-01
                                6    0.35267E-01    0.23481E-01
                                7    0.16086E-01    0.24567E-01
                                8    0.41738E-02    0.67799E-02
                                9    0.58516E-03    0.24514E-03
                                10   0.44740E-04    0.44740E-04
                                11   0.50000E-05    0.43456E-05
                                12   0.13710E-04    0.19340E-04
                                13   0.50331E-04    0.548370-04
                                14   0.18693E-03    0.20019E-03
                                15   0.67248E-03    0.23535E-03
                                16   0.22029E-02    0.11244E-02
                                17   0.59918E-02    0.60022E-02
                                18   0.12137E-01    0.23731E-01
                                19   0.17703E-01    0.19822E-01
                                20   0.18786E-01    0.12441E-01
                                21   0.14473E-01    0.29249E-01
                                22   0.79026E-02    0.08708E-02
                                23   0.29037E-02    0.33077E-02
                                24   0.69835E-03    0.54197E-03
                                25   0.11000E-03    0.21002E-03
                            </screen>
                        </figure>
                    </listitem>
                    <listitem>Detailed parameters.
                        <para>
                        In the next part of the output different atmospheric and surface parameters can be found. Which of them are shown and which are not is defined by the settings parameters in retrieval.products part. Each product is identified by a header where the name and some information is provided. The different columns corresponds to the different pixels analougously to the case of the vector of retrieved parameters.
                        </para>
                        <para>
                        If there are more than one atmospheric component in the retrieval the information corresponding to each mode is expressed differently depending on if it is an optical or microphysical product. In the case of microphysical products the information of the different components is expressed in different lines which start with an identificative integer.
                        </para>
                        <figure>
                            <title>An example of the aerosol volume concentration in &GRASP; classic output for two aerosol modes</title>
                            <screen>
                                <?db-font-size 70% ?>
Aerosol volume concentration (um^3/um^2 or um^3/um^3)
    1   0.47855E-01 0.68932E-01
    2   0.22771E-01 0.13793E-01
                            </screen>
                        </figure>
                        <para>
                        However, in the case of optical products, the corresponding mode of the product is indicated in the product header name, and each line is associated with a wavalength which is also indicated in the beginning of it.
                        </para>
                        <figure>
                            <title>An example of the Aerosol Optical Depth in &GRASP; classic output for two aerosol modes</title>
                            <screen>
                                <?db-font-size 70% ?>
Wavelength (um), AOD_Total (unitless or 1/um)
       0.44000   0.45107E+00   0.354561E+00
       0.67500   0.18630E+00   0.223511E+00
       0.87000   0.99709E-01   0.782688E-01
       1.02000   0.66909E-01   0.456723E-01
Wavelength (um), AOD_Particle_mode_1 (unitless or 1/um)
       0.44000   0.43880E+00   0.30345E+00
       0.67500   0.17344E+00   0.20230E+00
       0.87000   0.86553E-01   0.701544-01
       1.02000   0.53769E-01   0.405612E-01
Wavelength (um), AOD_Particle_mode_2 (unitless or 1/um)
       0.44000   0.12274E-01   0.54561E-01
       0.67500   0.12856E-01   0.23462E-01
       0.87000   0.13156E-01   0.82655E-02
       1.02000   0.13140E-01   0.65231E-02
                            </screen>
                        </figure>
                    </listitem>
                    <listitem>Information of the fitting.
                    <para>
                    In the final part of the &GRASP; classic output the information is organized in different blocks. In each of these blocks the measurements associated to each wavelength and pixel of the SDATA and the fitted measurements after the final iteration can be found. Each measurement is separated by a header where the measurement in the sdata is indicated as meas_+"measurement name", and the fitted as fit_+"measurement name".  If the measurement is defined by a specific geometry, this geometry is also included here. As for example the Solar Zenith Angle (sza), the zenith angle of the measurement (vis), the azimuth angle of the measurement (fis) or the corresponding scattering angle (sca_ang).
                    </para>
                    <figure>
                        <title>An example of the fitting information in &GRASP; classic output for one wavelenght of one pixel with TOD and irradiance measurements</title>
                        <screen>
                            <?db-font-size 70% ?>
------------------------------------------------------------------------
pixel #    1   wavelength #   1     0.440 (um)
------------------------------------------------------------------------
       meas_tod        fit_tod
    0.70302E+00    0.70290E+00
   #      sza      vis      fis  sca_ang         meas_I          fit_I
   1    70.00   110.00   183.50     3.29    0.67436E+00    0.67369E+00
   2    70.00   110.00   184.00     3.76    0.62857E+00    0.62765E+00
   3    70.00   110.00   185.00     4.70    0.57672E+00    0.57630E+00
   4    70.00   110.00   186.00     5.64    0.55140E+00    0.55151E+00
   5    70.00   110.00   187.00     6.58    0.53713E+00    0.53745E+00
   6    70.00   110.00   188.00     7.52    0.52757E+00    0.52796E+00
   7    70.00   110.00   190.00     9.40    0.51327E+00    0.51358E+00
   8    70.00   110.00   192.00    11.27    0.50043E+00    0.50059E+00
   9    70.00   110.00   194.00    13.15    0.48706E+00    0.48712E+00
  10    70.00   110.00   196.00    15.03    0.47341E+00    0.47335E+00
  11    70.00   110.00   198.00    16.91    0.45892E+00    0.45876E+00
  12    70.00   110.00   200.00    18.78    0.44384E+00    0.44361E+00
  13    70.00   110.00   205.00    23.47    0.40481E+00    0.40449E+00
  14    70.00   110.00   210.00    28.15    0.36583E+00    0.36555E+00
  15    70.00   110.00   215.00    32.83    0.32882E+00    0.32864E+00
  16    70.00   110.00   220.00    37.49    0.29500E+00    0.29489E+00
  17    70.00   110.00   225.00    42.15    0.26492E+00    0.26483E+00
  18    70.00   110.00   230.00    46.80    0.23864E+00    0.23853E+00
  19    70.00   110.00   240.00    56.05    0.19656E+00    0.19638E+00
  20    70.00   110.00   250.00    65.23    0.16617E+00    0.16595E+00
  21    70.00   110.00   260.00    74.32    0.14471E+00    0.14453E+00
  22    70.00   110.00   270.00    83.28    0.13010E+00    0.13000E+00
  23    70.00   110.00   280.00    92.08    0.12075E+00    0.12071E+00
  24    70.00   110.00   300.00   108.94    0.11330E+00    0.11323E+00
  25    70.00   110.00   320.00   124.02    0.11489E+00    0.11461E+00
  26    70.00   110.00   340.00   135.46    0.11897E+00    0.11849E+00
                        </screen>
                    </figure>
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>
    </sect1>
    
    <sect1>
        <title>Forward model</title>
        <para>
            &GRASP; has several forward models and each of them are used (or not) depending on the application. 
            For example, to retrieve nephelometer data, just single scattering (particle properties) will be used.
            For other applications, &GRASP; has also a multiple scattering module (radiative transfer) and a lidar 
            signal module.
        </para>
        <sect2>
            <title>How to use the forward model: Derived products and reprocesing data</title>
            <para>
                As it was explained in <xref linkend="sect-iguess" /> section, the retrieval algorithm works
                iteratively over an array of parameters (in its first definition it is called the initial guess), until
                it represents the best solution. This solution array has same shape as the initial guess (the same 
                parameters and defined in the same position). Once it is obtained, a final call of the forward model
                with the resulting array provides a complete list of output products.
            </para>
            <para>
                For some applications, it can be useful to use the forward model without inverting any data. It
                can be done easily in &GRASP; with the use of the setting parameter 
                retrieval.mode=forward. When no retrieval is performed, just one call
                of forward model is performed. If in the initial guess array the user has set an aerosol model, it will be used
                inside of the forward model obtaining therefore an entire output structure, with information in all fields.
            </para>
            <para>
                This procedure can be used also to reprocess some data. If output parameters of a retrieval are stored, then
                they can be set as initial guess and then, running &GRASP; with the same settings, except for retrieval.mode=forward
                the entire output can be obtained again. This procedure can be used to reprocess data with many objectives
                such as saving storage space (just save the output array of grasp and reprocess to obtain the rest, if it is needed) or
                obtaining extra products in the future.
            </para>
        </sect2>
        <sect2>
            <title>Synthetic data</title>
            <para>
                The previous procedure can also help to simulate the input data. It is useful because a valid geometry is necessary in the input data to set an SDATA file.
                In this case, an aerosol model is set as an initial guess and
                the code works just for the forward run.  Then, by using
                retrieval.debug.simulated_sdata_file parameter, the user can set a path to the simulated files. A SDATA file will be dump 
                to that path where the geometry is the same and the measurements are filled with the output results of the
                forward run. Then, this SDATA file can be used to self-consistency tests, where synthetic data is retrieved.
            </para>
        </sect2>
    </sect1>
    
    <sect1>
        <title>Aerosol modeling in &GRASP;</title>
        <para>
            Due to the versatility and the high degree of generalisation of &GRASP;, there are different approaches to model aerosols in order to maximize the possibilities of the different retrieval schemes. Each of the approaches described below presents different advantages depending on the information available in the input measurements, the desired output products or the available computation time.
        </para>
        
        <sect2>
            <title>Kernels</title>
            <para>
                In this approach the retrieved characteristics which determine the optical properties of aerosols are the size distribution, the real and imaginary refractive indexes, and the percentage of spherical particles (the non-spherical part is modeled as spheroids). The calculation of the radiative properties (phase matrix, scattering and absorption cross-sections) from these initial characteristics is made through four-dimensional look-up-tables called "Kernels".
            </para>
            <para>
                The four dimensions of the Kernels are: the size parameter, sphericity and the real and the imaginary refractive indices. Due to the extensive nature of these kernels, this approach represents the less restricted methodology, because any possible combination of the represented characteristics can be obtained as the solution.
            </para>
            <para>
                The lack of intrinsic restrictions of this approach (note that as in all &GRASP; retrievals, apriori constraints can be set for any characteristic) presents obvious advantages. However, the general nature of Kernels methodology normally requires input measurements containing a higher amount of information in comparison with other approaches.
            </para>
            <para>
                There are three different ways to represent the aerosol size distribution, from the most general to the simplest: triangle bins, lognormal bins and precalculated lognormal bins. The corresponding characteristics names in the &GRASP; YAML settings file are: “size_distribution_triangle_bins”, “size_distribution_lognormal” and “size_distribution_precalculated_lognormal”. Independently of the selected representation of the aerosol size distribution, the rest of the steps of this methodology to obtain aerosol radiative properties are the same.
            </para>
            <para>
                In the triangle bins representation the value of each bin is retrieved independently from the others, and it corresponds to the integrated value following the trapezoidal rule between the provided size limits. The lognormal bins approach is a simplified version of the former, where each aerosol size distribution mode is modeled as a gaussian function only represented by three parameters: the center, the standard deviation and the norm. The former value is the aerosol concentration of the corresponding mode. The precalculated lognormal bins size distribution represents a step further in the simplification of this characteristic. In this case each aerosol mode is also represented by a Gaussian function. However, the center and the standard deviation are fixed to a predefined value and only the norm (aerosol concentration) of each mode is retrieved.
            </para>
        </sect2>
        
        
        <sect2>
            <title>Models</title>
            <para>
                The main retrieved aerosol products of this approach are the fractions of the total aerosol concentration of precalculated aerosol models. These precalculated models correspond to the main aerosol types established by all our previous experiences (Ex: smoke, urban, oceanic and dust). Each of these models correspond to a fixed particle size distribution and refractive indices, containing the already calculated phase matrix, and the extinction and absorption cross-sections. The total aerosol retrieved characteristics can be obtained by weighting the characteristics used to calculate each of these models by its corresponding volume concentration.
            </para>
            
            <para>
                The significant reduction of retrieved parameters makes this approach very suitable for the retrieval of input measurements with a reduced amount of information. The absence of Kernels in the whole process makes this option by far the fastest of all. One of the main drawbacks of this methodology is the fact that the inversion is intrinsically constrained by the selected models. However, these models have been carefully selected to be suitable to cover almost all atmospheric situations. Moreover, they can be recalculated or extended in order to cover specific situations.
            </para>
            
            <para>
                An example of the necessary settings to use this approach can be found below. Where in the phase matrix section the bin of each mode no longer represents the limit radius but the accounted aerosol models. Particle size distribution, refractive indexes and sphericity characteristics are substituted by another characteristic called "aerosol_model_concentration".
            </para>
            
        
        <screen>
<?db-font-size 70% ?>
forward_model:

      phase_matrix:
          size_binning_method_for_triangle_bins: logarithm
          number_of_elements: 4
          kernels_folder: "models_ang35_wl22_optimized"
          radius:
              mode[1]:
                  bins: [ 1.,  2., 3., 4., 5. ]
                  
  .
  .
  .


  constraints:
      characteristic[1]:
          type: aerosol_model_concentration
          retrieved: true
          mode[1]:
              initial_guess:                       #smoke       #urban    #oceanic   #dust
                  value:                          [0.9,           0.4,      0.4,     0.4.,      0.4]
                  min:                            [0.000005, 0.000005, 0.000005, 0.000005, 0.000005]
                  max:                            [1.0,           1.0,      1.0,      1.0,      1.0]
                  index_of_wavelength_involved:   [0,               0,        0,        0,        0]
              single_pixel:
              .
              .
              .

      characteristic[2]:
          type: aerosol_concentration
          retrieved: true
          mode[1]:
              initial_guess:
                  value:                          [0.05   ]
                  min:                            [0.0001 ]
                  max:                            [5.0    ]
                  index_of_wavelength_involved:   [0      ]
              single_pixel:
              .
              .
              .

        </screen>
            
        </sect2>
        
        <sect2>
            <title>Chemistry</title>
            
            <para>
                The chemistry approach can be seen somehow as an intermediate approach between Kernels and Models. In this case size distribution and sphericity percentage are directly retrieved as in the case of Kernels. However, instead of the refractive indexes, here the fractions of the total aerosol concentration corresponding to the different chemical components are retrieved. The refractive indices corresponding to each of these components are predefined. Thus, the weighted refractive indexes of all the fractions in combination with the particle size distribution and the sphericity parameter are used as input for the Kernels look-up-tables to calculate the radiative properties.
            </para>
            
            <para>
                In comparison with the Models approach, where the radiative properties can only be linearly weighted, the refractive index presents an extra layer of complexity when they are mixed. Because the weighting methodology used to obtain the total refractive index retains information about the aerosol internal structure. Two mixing possibilities are available now in &GRASP;: an internal mixture, where a linear mixture of the different components is performed; but also a Maxwell-Garnett mixture is available, where one element is considered as the main host and the rest of the chemical elements are taken as inclusions inside of it.
            </para>
            
            <para>
                In this case the necessary settings to use this approach are very similar to Kernels. The size distribution can be represented using the three already described possibilities in the Kernels approach. However, the refractive index characteristics are substituted by  "particle_component_volume_fractions_linear_mixture" in the case of the linear mixture, or by "particle_component_fractions_chemical_mixture" in the case of a Maxwell-Garnett mixture. An extra section called "chemistry" has to be added in the Forward model part, where it is provided: the names of each chemical component accounted in the inversion, the soluble component (if necessary) and the path to the directory where these predefined refractive index look-up-tables are located.
            </para>
            
            <screen>
    <?db-font-size 70% ?>
    forward_model:

        aerosol:
            chemistry:
                folder: "chemistry_refractive_indexes/"
                soluble: "ammnm_ntrt"
                species:
                    mode[1]: [ 'black_carbon', 'mix_dust','iron_oxide','water']
                    
        phase_matrix:
            size_binning_method_for_triangle_bins: logarithm
            number_of_elements: 1
            kernels_folder: "KERNELS_BASE/"
            radius:
                mode[1]:
                    min: 0.05
                    max: 15.0
                    
    .
    .
    .


    constraints:
        characteristic[1]:
            type: size_distribution_triangle_bins
            retrieved: true
            mode[1]:
                initial_guess:
                    value:                        [1.4715e-05, 1.4715e-03, ..., 1.4715e-03, 1.4715e-05]
                    min:                          [0.00001,  0.00001,  ...,  0.00001,  0.00001]
                    max:                          [1.0,      1.0,      ...,      1.0,      1.0]
                    index_of_wavelength_involved: [0,        0,       ...,        0,        0]
            .
            .
            .
                        
        characteristic[2]:
            type: particle_component_volume_fractions_linear_mixture
            retrieved: true
            mode[1]:
                initial_guess:             #1         #2        #3         #4
                    value:                 [0.00001,       0.0001,      0.0001,      0.0001      ]
                    min:                   [0.000001,    0.000001,   0.000001,    0.000001   ]
                    max:                   [0.2,        1.0,       1.0,        1.0      ]
                    index_of_wavelength_involved:   [0,        0,      0,     0      ]
                .
                .
                .

        
            </screen>
        </sect2>

          <sect2>
            <title>Transport models</title>
            <para>
                The transport models approach constitutes the most complex methodology to model atmospheric aerosols. This approach has been designed to facilitate the interface between sophisticated aerosol transport models and &GRASP; code, both for forward modeling and retrieval. Normally, these complex transport models work simultaneously with a high number of different aerosol particles with specific size distributions, shape, optical characteristics, vertical distributions… In the rest of the &GRASP; approaches for aerosol modeling only one or two aerosol modes are considered which have all these aforementioned characteristics totally independent between each other. However, the GRASP transport model approach is not only an additional interface that enables the possibility to work with multiple independent aerosol modes. But it is also a tool that allows the conversion between the characteristics that define the particles in the aerosol transport models (as mass mixing ratio) to the normal microphysical and optical characteristics that are normally used in &GRASP;. 
            </para>
            
            <para>
                &GRASP; transport model approach consists of 5 main aerosol components similar to MERRA-2 and CAMS aerosol models: sulphate (SU), desert dust (DU), sea salt (SS), organic (OC) and black carbon (BC). Each component can exhibit hydrophobic or hydrophilic properties resulting in 15 aerosol tracers: hydrophilic sulphate (SU), five size bins for hydrophobic dust (DU) and hydrophilic sea salt (SS), hydrophobic and hydrophilic modes of organic (OC) and black carbon (BC) aerosol . The concentration and optical depth of each tracer in the model is refined through the mass mixing ratio.
                Furthermore, each of these aerosol modes count with its own vertical profile, particle size distribution, sphericity parameter and all the rest of optical characteristics. Note that the different aerosol tracers are externally mixed with vertically dependent  mass mixing ratios  to obtain the corresponding total aerosol optical properties. 
            </para>
            
            <para>
                An example of the necessary settings to define the additional aerosol parameters of the transport models can be found below:
            </para>
            
            <screen>
                <?db-font-size 70% ?>
                forward_model:
                    phase_matrix:            
                        size_binning_method_for_triangle_bins: logarithm
                        number_of_elements: 4 
                        use_transport_model: true
                        number_of_bins_for_lognormal_size_distribution: [ ^repeat(43;15) ]
                        transport_model: 
                            vertical_profile: column_average  #tracer_average
                            tracers:     ['du1', 'du2', 'du3', 'du4', 'du5','bc1','bc2','oc1','oc2','ss1', 'ss2', 'ss3', 'ss4', 'ss5','su1'  ]
                            hydrophilic: [  0,     0,     0,     0,     0,    0,    1,    0,    1,    1,     1,     1,     1,     1,    1   ]
                            #hydrophilic: [  0,     0,     0,     0,     0,    0,    0,    0,    0,    0,     0,     0,     0,     0,    0   ]
                            density:     [2500., 2650., 2650., 2650., 2650.,1000.,1000.,1800.,1800., 2200., 2200., 2200., 2200.,2200., 1700.]                            
                        kernels_folder:  'KERNELS_BASE' # 'merra2_data_base'
                        radius:
                            mode[1]: # du1
                                min: 0.08
                                max: 20.0
                            mode[2]: # du2
                                min: 0.08
                                max: 20.0
                            mode[3]: # du3
                                min: 0.08
                                max: 20.0
                            mode[4]: # du4
                                min: 0.08
                                max: 20.0
                            mode[5]: # du5
                                min: 0.08
                                max: 20.0
                            mode[6]: # bc1
                                min: 0.0001 #0.002
                                max: 5.0
                            mode[7]: # bc2
                                min: 0.0001 #0.002
                                max: 5.0
                            .
                            .
                            . 
            </screen>

            <para>
                Where “forward_model.phase_matrix.transport_model.tracers” refers to the 15 aerosol tracers.  “forward_model.phase_matrix.transport_model.density” and “forward_model.phase_matrix.transport_model.hyfrophilic”  mark correspondingly the density of dry tracers and their hygroscopic properties (“0” corresponds to hydrophobic and “1” corresponds to hydrophilic aerosol).
            </para>

            <para>
                The rest of the aerosol characteristics are defined following the standard GRASP settings convention for different aerosol modes:
            </para>

            <screen>
                <?db-font-size 70% ?>
                constraints:
                    characteristic[1]: #1
                        type: size_distribution_lognormal
                        retrieved: true
                        mode[1]: 
                            initial_guess: 
                                value:                        [0.6576, 0.2828]
                                min:                          [0.1,   0.1]
                                max:                          [3.0,   0.9]
                                index_of_wavelength_involved: [^repeat(0;2)]
                            single_pixel:
                                a_priori_estimates:
                                    lagrange_multiplier:      [1.0e-03,  1.0e-03]
                                smoothness_constraints:
                                    difference_order: 0
                                    lagrange_multiplier: 0.0
                        mode[2]: 
                            initial_guess: 
                                value:                        [1.2436, 0.25]
                                min:                          [0.1,   0.1]
                                max:                          [3.0,   0.9]
                                index_of_wavelength_involved: [^repeat(0;2)]
                            single_pixel:
                                a_priori_estimates:
                                    lagrange_multiplier:      [1.0e-03,  1.0e-03]
                                smoothness_constraints:
                                    difference_order: 0
                                    lagrange_multiplier: 0.0
                        mode[3]: 
                            initial_guess: 
                                value:                        [2.2969, 0.344]
                                min:                          [0.1,   0.1]
                                max:                          [3.0,   0.9]
                                index_of_wavelength_involved: [^repeat(0;2)]
                            single_pixel:
                                a_priori_estimates:
                                    lagrange_multiplier:      [1.0e-03,  1.0e-03]
                                smoothness_constraints:
                                    difference_order: 0
                                    lagrange_multiplier: 0.0
                        mode[4]: 
                            initial_guess: 
                                value:                        [5.3645, 0.707]
                                min:                          [0.1,   0.1]
                                max:                          [6.0,   0.9]
                                index_of_wavelength_involved: [^repeat(0;2)]
                            single_pixel:
                                a_priori_estimates:
                                    lagrange_multiplier:      [1.0e-03,  1.0e-03]
                                smoothness_constraints:
                                    difference_order: 0
                                    lagrange_multiplier: 0.0
                        .
                        .
                        .
                

                    characteristic[2]: 
                                type: tracer_level_concentration
                                retrieved: true
                                mode[1]: 
                                    initial_guess: 
                                        value:                        [^repeat(0.007;72)]
                                        min:                          [^repeat(1e-15;72)]
                                        max:                          [^repeat(0.500;72)]
                                        index_of_wavelength_involved: [^repeat(0;72)]
                                    single_pixel:
                                        a_priori_estimates:
                                            lagrange_multiplier:      [^repeat(0;72)]
                                        smoothness_constraints:
                                            difference_order: 0
                                            lagrange_multiplier: 0.0
                                mode[2]: 
                                    initial_guess: 
                                        value:                        [^repeat(0.007;72)]
                                        min:                          [^repeat(1e-15;72)]
                                        max:                          [^repeat(0.500;72)]
                                        index_of_wavelength_involved: [^repeat(0;72)]
                                    single_pixel:
                                        a_priori_estimates:
                                            lagrange_multiplier:      [^repeat(0;72)]
                                        smoothness_constraints:
                                            difference_order: 0
                                            lagrange_multiplier: 0.0
                                mode[3]: 
                                    initial_guess: 
                                        value:                        [^repeat(0.007;72)]
                                        min:                          [^repeat(1e-15;72)]
                                        max:                          [^repeat(0.500;72)]
                                        index_of_wavelength_involved: [^repeat(0;72)]
                                    single_pixel:
                                        a_priori_estimates:
                                            lagrange_multiplier:      [^repeat(0;72)]
                                        smoothness_constraints:
                                            difference_order: 0
                                            lagrange_multiplier: 0.0
                                mode[4]: 
                                    initial_guess: 
                                        value:                        [^repeat(0.007;72)]
                                        min:                          [^repeat(1e-15;72)]
                                        max:                          [^repeat(0.500;72)]
                                        index_of_wavelength_involved: [^repeat(0;72)]
                                    single_pixel:
                                        a_priori_estimates:
                                            lagrange_multiplier:      [^repeat(0;72)]
                                        smoothness_constraints:
                                            difference_order: 0
                                            lagrange_multiplier: 0.0

                    characteristic[3]: 
                                type: real_part_of_refractive_index_spectral_dependent
                                retrieved: true
                                mode[1]:
                                    initial_guess:                       #1         #2        #3        #4        #5        #6       
                                        value:                        [^repeat(1.53;7)]
                                        min:                          [^repeat(1.33;7)]
                                        max:                          [^repeat(1.6;7)]
                                        index_of_wavelength_involved: [^repeat(0;7)]
                                    single_pixel:
                                        smoothness_constraints:
                                            difference_order: 1
                                            lagrange_multiplier: 1.0e+1
                                    multi_pixel:
                                        smoothness_constraints:
                                            derivative_order_of_X_variability:    1
                                            lagrange_multiplier_of_X_variability: 1.0e-1                        
                                            derivative_order_of_Y_variability:    1
                                            lagrange_multiplier_of_Y_variability: 1.0e-1                     
                                            derivative_order_of_T_variability:    1
                                            lagrange_multiplier_of_T_variability: 2.0e-2                                               
                                mode[2]:
                                    initial_guess:                       #1         #2        #3        #4        #5        #6       
                                        value:                        [^repeat(1.53;7)]
                                        min:                          [^repeat(1.33;7)]
                                        max:                          [^repeat(1.6;7)]
                                        index_of_wavelength_involved: [^repeat(0;7)]
                                    single_pixel:
                                        smoothness_constraints:
                                            difference_order: 1
                                            lagrange_multiplier: 1.0e+1
                                    multi_pixel:
                                        smoothness_constraints:
                                            derivative_order_of_X_variability:    1
                                            lagrange_multiplier_of_X_variability: 1.0e-1                        
                                            derivative_order_of_Y_variability:    1
                                            lagrange_multiplier_of_Y_variability: 1.0e-1                     
                                            derivative_order_of_T_variability:    1
                                            lagrange_multiplier_of_T_variability: 2.0e-2                                               
                                mode[3]:
                                    initial_guess:                       #1         #2        #3        #4        #5        #6       
                                        value:                        [^repeat(1.53;7)]
                                        min:                          [^repeat(1.33;7)]
                                        max:                          [^repeat(1.6;7)]
                                        index_of_wavelength_involved: [^repeat(0;7)]
                                    single_pixel:
                                        smoothness_constraints:
                                            difference_order: 1
                                            lagrange_multiplier: 1.0e+1
                                    multi_pixel:
                                        smoothness_constraints:
                                            derivative_order_of_X_variability:    1
                                            lagrange_multiplier_of_X_variability: 1.0e-1                        
                                            derivative_order_of_Y_variability:    1
                                            lagrange_multiplier_of_Y_variability: 1.0e-1                     
                                            derivative_order_of_T_variability:    1
                                            lagrange_multiplier_of_T_variability: 2.0e-2       

                                .
                                .
                                .
            </screen>


        </sect2>
    </sect1>

    <sect1>
        <title>Error estimation</title>
        <para>
            &GRASP; provides rigorous dynamic error estimates of the retrieved characteristics, but also these calculations are available for some of the derived parameters that  &GRASP; calculates internally. 
        </para>

        <para>
           In order to perform the calculations some extra information for each measurement has to be provided in the &GRASP; settings file. Two different kinds of bias can be assumed: 
           “bias_measurements_synthetic” and “bias_equation”. The units of these bias are the same as the corresponding measurement and the “error_type” option establishes if they are taken as an absolute 
           or relative value to the measurement. An example of the definition of these settings can be found below:
        </para>

        <screen>
                <?db-font-size 70% ?>
                noises:
                    noise[1]:
                        standard_deviation_synthetic: 0.05
                        bias_measurements_synthetic: 0.05
                        bias_equation: 0.05
                        error_type:  relative
                        standard_deviation:  0.03
                        measurement_type[1]:
                            type: I
                            index_of_wavelength_involved: [ 1, 2, 3, 4 ]
                    noise[2]:
                        standard_deviation_synthetic: 0.01
                        bias_measurements_synthetic: 0.01
                        bias_equation: 0.01
                        error_type:  absolute
                        standard_deviation:  0.01
                        measurement_type[1]:
                            type: aod
                            index_of_wavelength_involved: [ 1, 2, 3, 4 ]

        </screen>

        <para>
            In a similar way to other products provided by &GRASP;, in the “products” section the “error_estimation” group it is possible to configure how these error estimates are made with the
             option “using_Levenberg-Marquardt”. In order to select to what magnitudes are applied, the setting “retrieved” establishes to provide the error estimates for all retrieved 
             characteristics, and in the “derived” group the user can select to what of the derived products (ex.: AOD, Angstrom Exponent, SSA…) these calculations will be applied:
        </para>

        <screen>
                <?db-font-size 70% ?>
                products:  
                    error_estimation:
                        using_Levenberg-Marquardt: true
                        derived:
                                aerosol:
                                    lidar: true
                                    optical_properties: true
                        retrieved: true 
        </screen>

        <para>
            The error estimation of the selected magnitudes, retrieved and derived, can be found in the end of the classic &GRASP; output file separated in three: “Total standard deviations”, 
            “Standard deviations” and “BIAS - Standard deviation”. An example of an output of the error estimates can be seen below:
        </para>

        <screen>
                <?db-font-size 70% ?>
                -------------------------------------------------------------------------
                Total standard deviations of retrieved parameter logarithms (~relative errors) :
                -------------------------------------------------------------------------
                Date:             2014-08-22
                Time:               14:58:12
                            1   0.84496E+00
                            2   0.59295E+00
                            3   0.32039E+00
                            4   0.12886E+00
                            5   0.10403E+00
                    .
                    .
                    .
                -------------------------------------------------------------------------
                Standard deviations of retrieved parameter logarithms (~relative errors) :
                -------------------------------------------------------------------------
                Date:             2014-08-22
                Time:               14:58:12
                            1   0.84343E+00
                            2   0.35544E+00
                            3   0.15784E+00
                            4   0.11046E+00
                            5   0.84152E-01
                        .
                    .
                    .


                ----------------------------------------------------------------------------------
                BIAS - Standard deviation of systematic errors of retrieved parameter logarithms :
                ----------------------------------------------------------------------------------
                Date:             2014-08-22
                Time:               14:58:12
                            1   0.50815E-01
                            2   0.47461E+00
                            3   0.27880E+00
                            4   0.66360E-01
                            5  -0.61162E-01
                                .
                    .
                    .

                INVSING = 0
                --------------------------------------------------------------------------------------------
                Total standard deviations of retrieved optical characteristic logarithms (~relative errors) :
                --------------------------------------------------------------------------------------------
                Date:             2014-08-22
                Time:               14:58:12
                Wavelength (um), Aerosol Optical Depth (Random) for Particle component 1
                        0.4400   0.17618E-01
                        0.6750   0.68020E-01
                        0.8700   0.86484E-01
                        1.0200   0.82026E-01
                Wavelength (um), Single Scattering Albedo (Random) for Particle component 1
                        0.4400   0.59979E-01
                        0.6750   0.49679E-01
                        0.8700   0.25789E-01
                        1.0200   0.22196E-01
                --------------------------------------------------------------------------------------
                Standard deviations of retrieved optical characteristic logarithms (~relative errors) :
                --------------------------------------------------------------------------------------
                Date:             2014-08-22
                Time:               14:58:12
                Wavelength (um), Aerosol Optical Depth (Random) for Particle component   1
                        0.4400   0.65241E-02
                        0.6750   0.13940E-01
                        0.8700   0.19455E-01
                        1.0200   0.25821E-01
                Wavelength (um), Single Scattering Albedo (Random) for Particle component   1
                        0.4400   0.12061E-01
                        0.6750   0.99402E-02
                        0.8700   0.13855E-01
                        1.0200   0.18953E-01
                -----------------------------------------------------------------------------------------------
                BIAS - Standard deviations of systematic errors of retrieved optical characteristic logarithms :
                -----------------------------------------------------------------------------------------------
                Date:             2014-08-22
                Time:               14:58:12
                Wavelength (um), Aerosol Optical Depth (Bias) for Particle mode 1
                        0.4400   0.16370E-01
                        0.6750   0.66575E-01
                        0.8700   0.84366E-01
                        1.0200   0.77988E-01
                Wavelength (um), Single Scattering Albedo (Bias) for Particle mode 1
                        0.4400   0.58718E-01
                        0.6750   0.48694E-01
                        0.8700   0.21934E-01
                        1.0200   0.13280E-01
        </screen>

        <para>
            In order to make a proper interpretation of the error estimates provided by &GRASP; two considerations have to be considered. First, the random (standard deviation) and the bias components
             for each parameter have to be added quadratically to obtain the total error:
        </para>


        <para>
            Secondly, &GRASP; operates in the logarithmic space, which includes de error estimates. Thus, some calculations are needed in order to represent together the value of the different
             magnitudes and the corresponding error estimates: 
        </para>

        <para>
            ln(a<superscript>*</superscript>) = ln(a) &#177; &sigma;<subscript>a</subscript>
        </para>

        <para>
            Thus:
        </para>
        
        <para>
            a exp( &sigma;<subscript>a</subscript>) = a<superscript>*</superscript><subscript>high</subscript>
        </para>

        <para>
            a exp( - &sigma;<subscript>a</subscript>) = a<superscript>*</superscript><subscript>low</subscript>
        </para>
    </sect1>

</chapter>
